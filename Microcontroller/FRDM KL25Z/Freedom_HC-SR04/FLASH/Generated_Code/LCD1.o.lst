   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"LCD1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	LCD1_SoftCharUE
  18              		.section	.rodata.LCD1_SoftCharUE,"a",%progbits
  19              		.align	2
  22              	LCD1_SoftCharUE:
  23 0000 11       		.byte	17
  24 0001 00       		.byte	0
  25 0002 11       		.byte	17
  26 0003 11       		.byte	17
  27 0004 11       		.byte	17
  28 0005 13       		.byte	19
  29 0006 0D       		.byte	13
  30 0007 00       		.byte	0
  31              		.global	LCD1_SoftCharAE
  32              		.section	.rodata.LCD1_SoftCharAE,"a",%progbits
  33              		.align	2
  36              	LCD1_SoftCharAE:
  37 0000 11       		.byte	17
  38 0001 00       		.byte	0
  39 0002 0E       		.byte	14
  40 0003 01       		.byte	1
  41 0004 0F       		.byte	15
  42 0005 11       		.byte	17
  43 0006 0F       		.byte	15
  44 0007 00       		.byte	0
  45              		.global	LCD1_SoftCharOE
  46              		.section	.rodata.LCD1_SoftCharOE,"a",%progbits
  47              		.align	2
  50              	LCD1_SoftCharOE:
  51 0000 11       		.byte	17
  52 0001 00       		.byte	0
  53 0002 0E       		.byte	14
  54 0003 11       		.byte	17
  55 0004 11       		.byte	17
  56 0005 11       		.byte	17
  57 0006 0E       		.byte	14
  58 0007 00       		.byte	0
  59              		.section	.text.DataGet,"ax",%progbits
  60              		.align	2
  61              		.code	16
  62              		.thumb_func
  64              	DataGet:
  65              	.LFB0:
  66              		.file 1 "../Generated_Code/LCD1.c"
   1:../Generated_Code/LCD1.c **** /* ###################################################################
   2:../Generated_Code/LCD1.c **** **     This component module is generated by Processor Expert. Do not modify it.
   3:../Generated_Code/LCD1.c **** **     Filename    : LCD1.c
   4:../Generated_Code/LCD1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/LCD1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/LCD1.c **** **     Component   : LCDHTA
   7:../Generated_Code/LCD1.c **** **     Version     : Component 01.022, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/LCD1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/LCD1.c **** **     Date/Time   : 2017-12-17, 19:56, # CodeGen: 44
  10:../Generated_Code/LCD1.c **** **     Abstract    :
  11:../Generated_Code/LCD1.c **** **          This component implements a driver for multiple 2x16 character displays.
  12:../Generated_Code/LCD1.c **** **     Settings    :
  13:../Generated_Code/LCD1.c **** **          Component name                                 : LCD1
  14:../Generated_Code/LCD1.c **** **          HW Interface                                   : 
  15:../Generated_Code/LCD1.c **** **            LCD Type                                     : generic
  16:../Generated_Code/LCD1.c **** **            LCD Lines                                    : 2
  17:../Generated_Code/LCD1.c **** **            Characters per Line                          : 16
  18:../Generated_Code/LCD1.c **** **            Line Addresses                               : 
  19:../Generated_Code/LCD1.c **** **              Line 1                                     : 00
  20:../Generated_Code/LCD1.c **** **              Line 2                                     : 40
  21:../Generated_Code/LCD1.c **** **              Line 3                                     : 10
  22:../Generated_Code/LCD1.c **** **              Line 4                                     : 50
  23:../Generated_Code/LCD1.c **** **            LCD Enable Signal                            : Disabled
  24:../Generated_Code/LCD1.c **** **            Read from Display                            : Enabled
  25:../Generated_Code/LCD1.c **** **              R/W signal                                 : CtrlPin
  26:../Generated_Code/LCD1.c **** **              Check Busy Flag                            : yes
  27:../Generated_Code/LCD1.c **** **            Wait (us)                                    : 0
  28:../Generated_Code/LCD1.c **** **            E signal                                     : CtrlPin
  29:../Generated_Code/LCD1.c **** **            E2                                           : Disabled
  30:../Generated_Code/LCD1.c **** **            RS signal                                    : CtrlPin
  31:../Generated_Code/LCD1.c **** **            Data/Control Bus                             : 
  32:../Generated_Code/LCD1.c **** **              Data/Control Bus Width                     : 4bit
  33:../Generated_Code/LCD1.c **** **              DB0..DB3                                   : Disabled
  34:../Generated_Code/LCD1.c **** **              DB4..DB7                                   : Enabled
  35:../Generated_Code/LCD1.c **** **                DB4                                      : DBpin
  36:../Generated_Code/LCD1.c **** **                DB5                                      : DBpin
  37:../Generated_Code/LCD1.c **** **                DB6                                      : DBpin
  38:../Generated_Code/LCD1.c **** **                DB7                                      : DBpin
  39:../Generated_Code/LCD1.c **** **              Bits/Byte Bus                              : Disabled
  40:../Generated_Code/LCD1.c **** **          System Interface                               : 
  41:../Generated_Code/LCD1.c **** **            Wait                                         : WAIT1
  42:../Generated_Code/LCD1.c **** **     Contents    :
  43:../Generated_Code/LCD1.c **** **         WriteLCDCommand  - void LCD1_WriteLCDCommand(byte cmd);
  44:../Generated_Code/LCD1.c **** **         Write            - void LCD1_Write(char ch);
  45:../Generated_Code/LCD1.c **** **         WriteLn          - void LCD1_WriteLn(void);
  46:../Generated_Code/LCD1.c **** **         WriteLineStr     - void LCD1_WriteLineStr(byte line, char *str);
  47:../Generated_Code/LCD1.c **** **         WriteString      - void LCD1_WriteString(char *str);
  48:../Generated_Code/LCD1.c **** **         ShiftLeft        - void LCD1_ShiftLeft(void);
  49:../Generated_Code/LCD1.c **** **         ShiftRight       - void LCD1_ShiftRight(void);
  50:../Generated_Code/LCD1.c **** **         GotoXY           - void LCD1_GotoXY(byte line, byte column);
  51:../Generated_Code/LCD1.c **** **         SetEntryMode     - void LCD1_SetEntryMode(bool increment, bool shiftLeft);
  52:../Generated_Code/LCD1.c **** **         CursorShiftRight - void LCD1_CursorShiftRight(void);
  53:../Generated_Code/LCD1.c **** **         CursorShiftLeft  - void LCD1_CursorShiftLeft(void);
  54:../Generated_Code/LCD1.c **** **         Home             - void LCD1_Home(void);
  55:../Generated_Code/LCD1.c **** **         Line             - void LCD1_Line(byte line);
  56:../Generated_Code/LCD1.c **** **         Clear            - void LCD1_Clear(void);
  57:../Generated_Code/LCD1.c **** **         UseDisplay       - byte LCD1_UseDisplay(byte display);
  58:../Generated_Code/LCD1.c **** **
  59:../Generated_Code/LCD1.c **** **     License   :  Open Source (LGPL)
  60:../Generated_Code/LCD1.c **** **     Copyright : (c) Copyright Erich Styger, 2008-2014, all rights reserved.
  61:../Generated_Code/LCD1.c **** **     http      : www.mcuoneclipse.com
  62:../Generated_Code/LCD1.c **** **     This an open source software implementing software using Processor Expert.
  63:../Generated_Code/LCD1.c **** **     This is a free software and is opened for education,  research  and commercial developments 
  64:../Generated_Code/LCD1.c **** **     * This is a free software and there is NO WARRANTY.
  65:../Generated_Code/LCD1.c **** **     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or
  66:../Generated_Code/LCD1.c **** **     * Redistributions of source code must retain the above copyright notice.
  67:../Generated_Code/LCD1.c **** ** ###################################################################*/
  68:../Generated_Code/LCD1.c **** /*!
  69:../Generated_Code/LCD1.c **** ** @file LCD1.c
  70:../Generated_Code/LCD1.c **** ** @version 01.00
  71:../Generated_Code/LCD1.c **** ** @brief
  72:../Generated_Code/LCD1.c **** **          This component implements a driver for multiple 2x16 character displays.
  73:../Generated_Code/LCD1.c **** */         
  74:../Generated_Code/LCD1.c **** /*!
  75:../Generated_Code/LCD1.c **** **  @addtogroup LCD1_module LCD1 module documentation
  76:../Generated_Code/LCD1.c **** **  @{
  77:../Generated_Code/LCD1.c **** */         
  78:../Generated_Code/LCD1.c **** 
  79:../Generated_Code/LCD1.c **** /* MODULE LCD1. */
  80:../Generated_Code/LCD1.c **** 
  81:../Generated_Code/LCD1.c **** #include "LCD1.h"
  82:../Generated_Code/LCD1.c **** 
  83:../Generated_Code/LCD1.c **** 
  84:../Generated_Code/LCD1.c **** /* DEFINES for display commands.
  85:../Generated_Code/LCD1.c ****    See
  86:../Generated_Code/LCD1.c ****    - www.freescale.com/files/microcontrollers/doc/app_note/AN1745.pdf
  87:../Generated_Code/LCD1.c ****    - http://www.mikrocontroller.net/articles/HD44780
  88:../Generated_Code/LCD1.c ****    for additional details.
  89:../Generated_Code/LCD1.c **** */
  90:../Generated_Code/LCD1.c **** #define ClearDisplayCmd                 0x01 /* clears the display */
  91:../Generated_Code/LCD1.c **** 
  92:../Generated_Code/LCD1.c **** #define ReturnHomeCmd                   0x02 /* moves the cursor to the beginning of the first line
  93:../Generated_Code/LCD1.c **** 
  94:../Generated_Code/LCD1.c **** #define EntryModeSetCmd                 0x04
  95:../Generated_Code/LCD1.c ****   #define EntryModeSet_ShiftOn             1 /* S flag: shift display */
  96:../Generated_Code/LCD1.c ****   #define EntryModeSet_IncrementOn         2 /* I/D flag: increment cursor */
  97:../Generated_Code/LCD1.c **** 
  98:../Generated_Code/LCD1.c **** #define DisplayOnOffControlCmd          0x08 /* Display on/off control command. There are 3 bits D,
  99:../Generated_Code/LCD1.c ****   #define DisplayOnOffControl_BlinkOn      1 /* B flag: blinking cursor on/off; B=1 blinking, B=0 n
 100:../Generated_Code/LCD1.c ****   #define DisplayOnOffControl_CursorOn     2 /* C flag: cursor on/off, C=1 cursor on, C=0 cursor of
 101:../Generated_Code/LCD1.c ****   #define DisplayOnOffControl_DisplayOn    4 /* D flag: display on/off, D=1 display on, D=0 display
 102:../Generated_Code/LCD1.c **** 
 103:../Generated_Code/LCD1.c **** #define FunctionSetCmd                  0x20
 104:../Generated_Code/LCD1.c ****   #define FunctionSet_8bit              0x10 /* DL flag: DL=1: 8bit, DL=0: 4bit */
 105:../Generated_Code/LCD1.c ****   #define FunctionSet_4bit                 0 /* DL flag: DL=1: 8bit, DL=0: 4bit */
 106:../Generated_Code/LCD1.c ****   #define FunctionSet_2Lines            0x08 /* N flag: number of display lines: N=1 2 or 4 lines, 
 107:../Generated_Code/LCD1.c ****   #define FunctionSet_1Line                0 /* N flag: number of display lines: N=1 2 or 4 lines, 
 108:../Generated_Code/LCD1.c ****   #define FunctionSet_Font5x10          0x04 /* F flag: character font, F=1 5x10 dots, F=0 5x8 dots
 109:../Generated_Code/LCD1.c ****   #define FunctionSet_Font5x8              0 /* F flag: character font, F=1 5x10 dots, F=0 5x8 dots
 110:../Generated_Code/LCD1.c **** 
 111:../Generated_Code/LCD1.c **** #define CursorOnCmd    (DisplayOnOffControlCmd|DisplayOnOffControl_DisplayOn|DisplayOnOffControl_Cu
 112:../Generated_Code/LCD1.c **** #define CursorOffCmd   (DisplayOnOffControlCmd|DisplayOnOffControl_DisplayOn)
 113:../Generated_Code/LCD1.c **** #define GotoXYCmd      0x80  /* 0x80 | Display RAM address */
 114:../Generated_Code/LCD1.c **** #define Line1Offset    0x00 /* Display RAM address of first line, usually 0x00 */
 115:../Generated_Code/LCD1.c **** #define Line2Offset    0x40 /* Display RAM address of second line, usually 0x40 */
 116:../Generated_Code/LCD1.c **** #define Line3Offset    0x10 /* Display RAM address of third line, usually 0x10 */
 117:../Generated_Code/LCD1.c **** #define Line4Offset    0x50 /* Display RAM address of fourth line, usually 0x50 */
 118:../Generated_Code/LCD1.c **** #define FirstLineCmd   (GotoXYCmd|Line1Offset)
 119:../Generated_Code/LCD1.c **** #define SecondLineCmd  (GotoXYCmd|Line2Offset)
 120:../Generated_Code/LCD1.c **** #define ThirdLineCmd   (GotoXYCmd|Line3Offset)
 121:../Generated_Code/LCD1.c **** #define FourthLineCmd  (GotoXYCmd|Line4Offset)
 122:../Generated_Code/LCD1.c **** 
 123:../Generated_Code/LCD1.c **** #define RightShiftCmd      0x1C
 124:../Generated_Code/LCD1.c **** #define LeftShiftCmd       0x18
 125:../Generated_Code/LCD1.c **** #define RightShiftCursor   0x14
 126:../Generated_Code/LCD1.c **** #define LeftShiftCursor    0x10
 127:../Generated_Code/LCD1.c **** 
 128:../Generated_Code/LCD1.c **** #define BusyFlag       0x80 /* BF Flag */
 129:../Generated_Code/LCD1.c **** 
 130:../Generated_Code/LCD1.c **** /* support for custom soft characters in the display which can be used with LCD1_LoadSoftChar() */
 131:../Generated_Code/LCD1.c **** const byte LCD1_SoftCharUE[8] = { /* ü */
 132:../Generated_Code/LCD1.c ****   0x11, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0d, 0
 133:../Generated_Code/LCD1.c **** /* X...X
 134:../Generated_Code/LCD1.c ****    .....
 135:../Generated_Code/LCD1.c ****    X...X
 136:../Generated_Code/LCD1.c ****    X...X
 137:../Generated_Code/LCD1.c ****    X...X
 138:../Generated_Code/LCD1.c ****    X..XX
 139:../Generated_Code/LCD1.c ****    .XX.X */
 140:../Generated_Code/LCD1.c **** };
 141:../Generated_Code/LCD1.c **** 
 142:../Generated_Code/LCD1.c **** const byte LCD1_SoftCharAE[8] = { /* ä */
 143:../Generated_Code/LCD1.c ****   0x11, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F, 0
 144:../Generated_Code/LCD1.c **** /* X...X
 145:../Generated_Code/LCD1.c ****    .....
 146:../Generated_Code/LCD1.c ****    .XXX.
 147:../Generated_Code/LCD1.c ****    ....X
 148:../Generated_Code/LCD1.c ****    .XXXX
 149:../Generated_Code/LCD1.c ****    X...X
 150:../Generated_Code/LCD1.c ****    .XXXX */
 151:../Generated_Code/LCD1.c **** };
 152:../Generated_Code/LCD1.c **** 
 153:../Generated_Code/LCD1.c **** const byte LCD1_SoftCharOE[8] = { /* ö */
 154:../Generated_Code/LCD1.c ****   0x11, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E, 0
 155:../Generated_Code/LCD1.c **** /* X...X
 156:../Generated_Code/LCD1.c ****    .....
 157:../Generated_Code/LCD1.c ****    .XXX.
 158:../Generated_Code/LCD1.c ****    X...X
 159:../Generated_Code/LCD1.c ****    X...X
 160:../Generated_Code/LCD1.c ****    X...X
 161:../Generated_Code/LCD1.c ****    .XXX. */
 162:../Generated_Code/LCD1.c **** };
 163:../Generated_Code/LCD1.c **** 
 164:../Generated_Code/LCD1.c **** /* macros for the RW pin */
 165:../Generated_Code/LCD1.c **** #define ClrRW() \
 166:../Generated_Code/LCD1.c ****         RW1_ClrVal()                    /* RW=0: write mode */
 167:../Generated_Code/LCD1.c **** #define SetRW() \
 168:../Generated_Code/LCD1.c ****         RW1_SetVal()                    /* RW=1: read mode */
 169:../Generated_Code/LCD1.c **** 
 170:../Generated_Code/LCD1.c **** /* macros for the RS pin */
 171:../Generated_Code/LCD1.c **** #define ClrRS() \
 172:../Generated_Code/LCD1.c ****         RS1_ClrVal()                    /* RS=0: command mode */
 173:../Generated_Code/LCD1.c **** #define SetRS() \
 174:../Generated_Code/LCD1.c ****         RS1_SetVal()                    /* RS=1: data mode */
 175:../Generated_Code/LCD1.c **** 
 176:../Generated_Code/LCD1.c **** /* macros for the EN pin */
 177:../Generated_Code/LCD1.c **** #define ClrEN() \
 178:../Generated_Code/LCD1.c ****         EN1_ClrVal()                    /* EN=0 */
 179:../Generated_Code/LCD1.c **** #define SetEN() \
 180:../Generated_Code/LCD1.c ****         EN1_SetVal()                    /* EN=1 */
 181:../Generated_Code/LCD1.c **** 
 182:../Generated_Code/LCD1.c **** /* macros for the data bus */
 183:../Generated_Code/LCD1.c **** #define DataAsOutput() \
 184:../Generated_Code/LCD1.c ****         DB41_SetOutput();               /* set data port as output */ \
 185:../Generated_Code/LCD1.c ****         DB51_SetOutput();               /* set data port as output */ \
 186:../Generated_Code/LCD1.c ****         DB61_SetOutput();               /* set data port as output */ \
 187:../Generated_Code/LCD1.c ****         DB71_SetOutput()                /* set data port as output */
 188:../Generated_Code/LCD1.c **** #define DataAsInput() \
 189:../Generated_Code/LCD1.c ****         DB41_SetInput();                /* set data port as input */ \
 190:../Generated_Code/LCD1.c ****         DB51_SetInput();                /* set data port as input */ \
 191:../Generated_Code/LCD1.c ****         DB61_SetInput();                /* set data port as input */ \
 192:../Generated_Code/LCD1.c ****         DB71_SetInput()                 /* set data port as input */
 193:../Generated_Code/LCD1.c **** 
 194:../Generated_Code/LCD1.c **** /* waiting macros */
 195:../Generated_Code/LCD1.c **** #define Waitns(x) \
 196:../Generated_Code/LCD1.c ****         WAIT1_Waitns(x)                 /* Wait x ns */
 197:../Generated_Code/LCD1.c **** #define Waitus(x) \
 198:../Generated_Code/LCD1.c ****         WAIT1_Waitus(x)                 /* Wait x us */
 199:../Generated_Code/LCD1.c **** #define Waitms(x) \
 200:../Generated_Code/LCD1.c ****         WAIT1_Waitms(x)                 /* Wait x ms */
 201:../Generated_Code/LCD1.c **** 
 202:../Generated_Code/LCD1.c **** /* timings from Hitachi HD44708.pdf */
 203:../Generated_Code/LCD1.c **** #define Timing_PWeh_ns   230 /* PWeh: Enable Pulse width (high level) */
 204:../Generated_Code/LCD1.c **** #define Timing_tAS_ns     40 /* tAB: Address set-up time (RS, RW to E ) */
 205:../Generated_Code/LCD1.c **** #define Timing_tDDR_ns   160 /* tDDR: Data delay time */
 206:../Generated_Code/LCD1.c **** #define Timing_tCYCLE_ns 500 /* tCYLE: Enable Cycle time */
 207:../Generated_Code/LCD1.c **** 
 208:../Generated_Code/LCD1.c **** #define LCD1_WAIT_DISPLAY_US      0 /* wait time as specified in properties */
 209:../Generated_Code/LCD1.c **** #define LCD1_WAIT_LCD_CMD_AFTER_4BIT_DATA1_US     15 /* wait time after first 4bit data */
 210:../Generated_Code/LCD1.c **** #define LCD1_WAIT_LCD_CMD_AFTER_4BIT_DATA2_US     60 /* wait time after second 4bit data */
 211:../Generated_Code/LCD1.c **** 
 212:../Generated_Code/LCD1.c **** static uint8_t DataGet(void) {
  67              		.loc 1 212 0
  68              		.cfi_startproc
  69 0000 90B5     		push	{r4, r7, lr}
  70              	.LCFI0:
  71              		.cfi_def_cfa_offset 12
  72              		.cfi_offset 4, -12
  73              		.cfi_offset 7, -8
  74              		.cfi_offset 14, -4
  75 0002 83B0     		sub	sp, sp, #12
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 24
  78 0004 00AF     		add	r7, sp, #0
  79              	.LCFI2:
  80              		.cfi_def_cfa_register 7
 213:../Generated_Code/LCD1.c ****   uint8_t val;
 214:../Generated_Code/LCD1.c **** 
 215:../Generated_Code/LCD1.c ****   val =  (DB71_GetVal()<<3)
  81              		.loc 1 215 0
  82 0006 184B     		ldr	r3, .L3
  83 0008 DB6A     		ldr	r3, [r3, #44]
  84 000a 181C     		mov	r0, r3
  85 000c FFF7FEFF 		bl	BitIoLdd13_GetVal
  86 0010 031C     		mov	r3, r0
  87 0012 DB00     		lsl	r3, r3, #3
  88 0014 DCB2     		uxtb	r4, r3
 216:../Generated_Code/LCD1.c ****         |(DB61_GetVal()<<2)
  89              		.loc 1 216 0
  90 0016 144B     		ldr	r3, .L3
  91 0018 9B6A     		ldr	r3, [r3, #40]
  92 001a 181C     		mov	r0, r3
  93 001c FFF7FEFF 		bl	BitIoLdd12_GetVal
  94 0020 031C     		mov	r3, r0
  95 0022 9B00     		lsl	r3, r3, #2
 215:../Generated_Code/LCD1.c ****   val =  (DB71_GetVal()<<3)
  96              		.loc 1 215 0
  97 0024 DBB2     		uxtb	r3, r3
  98 0026 221C     		add	r2, r4, #0
  99 0028 1343     		orr	r3, r2
 100 002a DCB2     		uxtb	r4, r3
 217:../Generated_Code/LCD1.c ****         |(DB51_GetVal()<<1)
 101              		.loc 1 217 0
 102 002c 0E4B     		ldr	r3, .L3
 103 002e 5B6A     		ldr	r3, [r3, #36]
 104 0030 181C     		mov	r0, r3
 105 0032 FFF7FEFF 		bl	BitIoLdd11_GetVal
 106 0036 031C     		mov	r3, r0
 107 0038 5B00     		lsl	r3, r3, #1
 215:../Generated_Code/LCD1.c ****   val =  (DB71_GetVal()<<3)
 108              		.loc 1 215 0
 109 003a DBB2     		uxtb	r3, r3
 110 003c 221C     		add	r2, r4, #0
 111 003e 1343     		orr	r3, r2
 112 0040 DCB2     		uxtb	r4, r3
 218:../Generated_Code/LCD1.c ****         |(DB41_GetVal()<<0);
 113              		.loc 1 218 0
 114 0042 094B     		ldr	r3, .L3
 115 0044 1B6A     		ldr	r3, [r3, #32]
 116 0046 181C     		mov	r0, r3
 117 0048 FFF7FEFF 		bl	BitIoLdd10_GetVal
 118 004c 031C     		mov	r3, r0
 215:../Generated_Code/LCD1.c ****   val =  (DB71_GetVal()<<3)
 119              		.loc 1 215 0
 120 004e DBB2     		uxtb	r3, r3
 121 0050 221C     		add	r2, r4, #0
 122 0052 1343     		orr	r3, r2
 123 0054 DAB2     		uxtb	r2, r3
 124 0056 FB1D     		add	r3, r7, #7
 125 0058 1A70     		strb	r2, [r3]
 219:../Generated_Code/LCD1.c ****   return val;
 126              		.loc 1 219 0
 127 005a FB1D     		add	r3, r7, #7
 128 005c 1B78     		ldrb	r3, [r3]
 220:../Generated_Code/LCD1.c **** }
 129              		.loc 1 220 0
 130 005e 181C     		mov	r0, r3
 131 0060 BD46     		mov	sp, r7
 132 0062 03B0     		add	sp, sp, #12
 133              		@ sp needed for prologue
 134 0064 90BD     		pop	{r4, r7, pc}
 135              	.L4:
 136 0066 C046     		.align	2
 137              	.L3:
 138 0068 00000000 		.word	PE_LDD_DeviceDataList
 139              		.cfi_endproc
 140              	.LFE0:
 142              		.section	.text.DataPut,"ax",%progbits
 143              		.align	2
 144              		.code	16
 145              		.thumb_func
 147              	DataPut:
 148              	.LFB1:
 221:../Generated_Code/LCD1.c **** 
 222:../Generated_Code/LCD1.c **** static void DataPut(uint8_t val) {
 149              		.loc 1 222 0
 150              		.cfi_startproc
 151 0000 80B5     		push	{r7, lr}
 152              	.LCFI3:
 153              		.cfi_def_cfa_offset 8
 154              		.cfi_offset 7, -8
 155              		.cfi_offset 14, -4
 156 0002 82B0     		sub	sp, sp, #8
 157              	.LCFI4:
 158              		.cfi_def_cfa_offset 16
 159 0004 00AF     		add	r7, sp, #0
 160              	.LCFI5:
 161              		.cfi_def_cfa_register 7
 162 0006 021C     		mov	r2, r0
 163 0008 FB1D     		add	r3, r7, #7
 164 000a 1A70     		strb	r2, [r3]
 223:../Generated_Code/LCD1.c ****   DB71_PutVal((val&(1<<3))!=0);
 165              		.loc 1 223 0
 166 000c 1B4B     		ldr	r3, .L6
 167 000e DA6A     		ldr	r2, [r3, #44]
 168 0010 FB1D     		add	r3, r7, #7
 169 0012 1978     		ldrb	r1, [r3]
 170 0014 0823     		mov	r3, #8
 171 0016 0B40     		and	r3, r1
 172 0018 591E     		sub	r1, r3, #1
 173 001a 8B41     		sbc	r3, r3, r1
 174 001c DBB2     		uxtb	r3, r3
 175 001e 101C     		mov	r0, r2
 176 0020 191C     		mov	r1, r3
 177 0022 FFF7FEFF 		bl	BitIoLdd13_PutVal
 224:../Generated_Code/LCD1.c ****   DB61_PutVal((val&(1<<2))!=0);
 178              		.loc 1 224 0
 179 0026 154B     		ldr	r3, .L6
 180 0028 9A6A     		ldr	r2, [r3, #40]
 181 002a FB1D     		add	r3, r7, #7
 182 002c 1978     		ldrb	r1, [r3]
 183 002e 0423     		mov	r3, #4
 184 0030 0B40     		and	r3, r1
 185 0032 591E     		sub	r1, r3, #1
 186 0034 8B41     		sbc	r3, r3, r1
 187 0036 DBB2     		uxtb	r3, r3
 188 0038 101C     		mov	r0, r2
 189 003a 191C     		mov	r1, r3
 190 003c FFF7FEFF 		bl	BitIoLdd12_PutVal
 225:../Generated_Code/LCD1.c ****   DB51_PutVal((val&(1<<1))!=0);
 191              		.loc 1 225 0
 192 0040 0E4B     		ldr	r3, .L6
 193 0042 5A6A     		ldr	r2, [r3, #36]
 194 0044 FB1D     		add	r3, r7, #7
 195 0046 1978     		ldrb	r1, [r3]
 196 0048 0223     		mov	r3, #2
 197 004a 0B40     		and	r3, r1
 198 004c 591E     		sub	r1, r3, #1
 199 004e 8B41     		sbc	r3, r3, r1
 200 0050 DBB2     		uxtb	r3, r3
 201 0052 101C     		mov	r0, r2
 202 0054 191C     		mov	r1, r3
 203 0056 FFF7FEFF 		bl	BitIoLdd11_PutVal
 226:../Generated_Code/LCD1.c ****   DB41_PutVal((val&(1<<0))!=0);
 204              		.loc 1 226 0
 205 005a 084B     		ldr	r3, .L6
 206 005c 1A6A     		ldr	r2, [r3, #32]
 207 005e FB1D     		add	r3, r7, #7
 208 0060 1978     		ldrb	r1, [r3]
 209 0062 0123     		mov	r3, #1
 210 0064 0B40     		and	r3, r1
 211 0066 591E     		sub	r1, r3, #1
 212 0068 8B41     		sbc	r3, r3, r1
 213 006a DBB2     		uxtb	r3, r3
 214 006c 101C     		mov	r0, r2
 215 006e 191C     		mov	r1, r3
 216 0070 FFF7FEFF 		bl	BitIoLdd10_PutVal
 227:../Generated_Code/LCD1.c **** }
 217              		.loc 1 227 0
 218 0074 BD46     		mov	sp, r7
 219 0076 02B0     		add	sp, sp, #8
 220              		@ sp needed for prologue
 221 0078 80BD     		pop	{r7, pc}
 222              	.L7:
 223 007a C046     		.align	2
 224              	.L6:
 225 007c 00000000 		.word	PE_LDD_DeviceDataList
 226              		.cfi_endproc
 227              	.LFE1:
 229              		.section	.text.EnablePulse,"ax",%progbits
 230              		.align	2
 231              		.code	16
 232              		.thumb_func
 234              	EnablePulse:
 235              	.LFB2:
 228:../Generated_Code/LCD1.c **** 
 229:../Generated_Code/LCD1.c **** /* Internal method prototypes */
 230:../Generated_Code/LCD1.c **** static void EnablePulse(void);
 231:../Generated_Code/LCD1.c **** 
 232:../Generated_Code/LCD1.c **** /*
 233:../Generated_Code/LCD1.c **** ** ===================================================================
 234:../Generated_Code/LCD1.c **** **     Method      :  EnablePulse (component LCDHTA)
 235:../Generated_Code/LCD1.c **** **
 236:../Generated_Code/LCD1.c **** **     Description :
 237:../Generated_Code/LCD1.c **** **         Creates a pulse to transfer data and/or commands
 238:../Generated_Code/LCD1.c **** **         This method is internal. It is used by Processor Expert only.
 239:../Generated_Code/LCD1.c **** ** ===================================================================
 240:../Generated_Code/LCD1.c **** */
 241:../Generated_Code/LCD1.c **** static void EnablePulse(void)
 242:../Generated_Code/LCD1.c **** {
 236              		.loc 1 242 0
 237              		.cfi_startproc
 238 0000 80B5     		push	{r7, lr}
 239              	.LCFI6:
 240              		.cfi_def_cfa_offset 8
 241              		.cfi_offset 7, -8
 242              		.cfi_offset 14, -4
 243 0002 00AF     		add	r7, sp, #0
 244              	.LCFI7:
 245              		.cfi_def_cfa_register 7
 243:../Generated_Code/LCD1.c ****   SetEN();
 246              		.loc 1 243 0
 247 0004 064B     		ldr	r3, .L9
 248 0006 9B69     		ldr	r3, [r3, #24]
 249 0008 181C     		mov	r0, r3
 250 000a FFF7FEFF 		bl	BitIoLdd4_SetVal
 244:../Generated_Code/LCD1.c ****   Waitns(Timing_PWeh_ns);
 251              		.loc 1 244 0
 252 000e FFF7FEFF 		bl	WAIT1_Wait10Cycles
 245:../Generated_Code/LCD1.c ****   ClrEN();                              /* set to 0 to finish pulse */
 253              		.loc 1 245 0
 254 0012 034B     		ldr	r3, .L9
 255 0014 9B69     		ldr	r3, [r3, #24]
 256 0016 181C     		mov	r0, r3
 257 0018 FFF7FEFF 		bl	BitIoLdd4_ClrVal
 246:../Generated_Code/LCD1.c **** }
 258              		.loc 1 246 0
 259 001c BD46     		mov	sp, r7
 260              		@ sp needed for prologue
 261 001e 80BD     		pop	{r7, pc}
 262              	.L10:
 263              		.align	2
 264              	.L9:
 265 0020 00000000 		.word	PE_LDD_DeviceDataList
 266              		.cfi_endproc
 267              	.LFE2:
 269              		.section	.text.LCD1_WaitForLCDReady,"ax",%progbits
 270              		.align	2
 271              		.global	LCD1_WaitForLCDReady
 272              		.code	16
 273              		.thumb_func
 275              	LCD1_WaitForLCDReady:
 276              	.LFB3:
 247:../Generated_Code/LCD1.c **** 
 248:../Generated_Code/LCD1.c **** /*
 249:../Generated_Code/LCD1.c **** ** ===================================================================
 250:../Generated_Code/LCD1.c **** **     Method      :  LCD1_WaitForLCDReady (component LCDHTA)
 251:../Generated_Code/LCD1.c **** **
 252:../Generated_Code/LCD1.c **** **     Description :
 253:../Generated_Code/LCD1.c **** **         Waits until the display is ready
 254:../Generated_Code/LCD1.c **** **         This method is internal. It is used by Processor Expert only.
 255:../Generated_Code/LCD1.c **** ** ===================================================================
 256:../Generated_Code/LCD1.c **** */
 257:../Generated_Code/LCD1.c **** void LCD1_WaitForLCDReady(void)
 258:../Generated_Code/LCD1.c **** {
 277              		.loc 1 258 0
 278              		.cfi_startproc
 279 0000 80B5     		push	{r7, lr}
 280              	.LCFI8:
 281              		.cfi_def_cfa_offset 8
 282              		.cfi_offset 7, -8
 283              		.cfi_offset 14, -4
 284 0002 82B0     		sub	sp, sp, #8
 285              	.LCFI9:
 286              		.cfi_def_cfa_offset 16
 287 0004 00AF     		add	r7, sp, #0
 288              	.LCFI10:
 289              		.cfi_def_cfa_register 7
 259:../Generated_Code/LCD1.c ****   byte ch;
 260:../Generated_Code/LCD1.c **** 
 261:../Generated_Code/LCD1.c ****   /* Wait until the display is ready for new data.
 262:../Generated_Code/LCD1.c ****      This means that we wait until the busy flag (MSB) in the status register is cleared */
 263:../Generated_Code/LCD1.c ****   DataAsInput();                        /* set data port as input */
 290              		.loc 1 263 0
 291 0006 364B     		ldr	r3, .L17
 292 0008 1B6A     		ldr	r3, [r3, #32]
 293 000a 181C     		mov	r0, r3
 294 000c FFF7FEFF 		bl	BitIoLdd10_SetInput
 295 0010 334B     		ldr	r3, .L17
 296 0012 5B6A     		ldr	r3, [r3, #36]
 297 0014 181C     		mov	r0, r3
 298 0016 FFF7FEFF 		bl	BitIoLdd11_SetInput
 299 001a 314B     		ldr	r3, .L17
 300 001c 9B6A     		ldr	r3, [r3, #40]
 301 001e 181C     		mov	r0, r3
 302 0020 FFF7FEFF 		bl	BitIoLdd12_SetInput
 303 0024 2E4B     		ldr	r3, .L17
 304 0026 DB6A     		ldr	r3, [r3, #44]
 305 0028 181C     		mov	r0, r3
 306 002a FFF7FEFF 		bl	BitIoLdd13_SetInput
 264:../Generated_Code/LCD1.c ****   SetRW();                              /* RW = 1: read mode */
 307              		.loc 1 264 0
 308 002e 2C4B     		ldr	r3, .L17
 309 0030 5B69     		ldr	r3, [r3, #20]
 310 0032 181C     		mov	r0, r3
 311 0034 FFF7FEFF 		bl	BitIoLdd15_SetVal
 312              	.L14:
 265:../Generated_Code/LCD1.c ****   Waitns(Timing_tAS_ns);
 266:../Generated_Code/LCD1.c ****   for(;;) {                             /* loop breaks as soon the busy flag is cleared */
 267:../Generated_Code/LCD1.c ****     SetEN();                            /* EN = 1; EN to high for getting the busy flag  */
 313              		.loc 1 267 0
 314 0038 294B     		ldr	r3, .L17
 315 003a 9B69     		ldr	r3, [r3, #24]
 316 003c 181C     		mov	r0, r3
 317 003e FFF7FEFF 		bl	BitIoLdd4_SetVal
 268:../Generated_Code/LCD1.c ****     Waitns(Timing_tDDR_ns);             /* Read mode timing tDDR: time until we can read data */
 318              		.loc 1 268 0
 319 0042 FFF7FEFF 		bl	WAIT1_Wait10Cycles
 269:../Generated_Code/LCD1.c ****     /* for 4bit data bus: need to do read twice */
 270:../Generated_Code/LCD1.c ****     ch = (byte)(DataGet()<<4);          /* read high byte */
 320              		.loc 1 270 0
 321 0046 FFF7FEFF 		bl	DataGet
 322 004a 031C     		mov	r3, r0
 323 004c 1A1C     		mov	r2, r3
 324 004e FB1D     		add	r3, r7, #7
 325 0050 1201     		lsl	r2, r2, #4
 326 0052 1A70     		strb	r2, [r3]
 271:../Generated_Code/LCD1.c ****     Waitns(Timing_PWeh_ns-Timing_tDDR_ns); /* for accurate lenght of EN pulse */
 327              		.loc 1 271 0
 328 0054 FFF7FEFF 		bl	WAIT1_Wait10Cycles
 272:../Generated_Code/LCD1.c ****     ClrEN();
 329              		.loc 1 272 0
 330 0058 214B     		ldr	r3, .L17
 331 005a 9B69     		ldr	r3, [r3, #24]
 332 005c 181C     		mov	r0, r3
 333 005e FFF7FEFF 		bl	BitIoLdd4_ClrVal
 273:../Generated_Code/LCD1.c ****     Waitns(Timing_tCYCLE_ns-Timing_PWeh_ns); /* need to wait a cycle time until we can enable EN ag
 334              		.loc 1 273 0
 335 0062 FFF7FEFF 		bl	WAIT1_Wait10Cycles
 274:../Generated_Code/LCD1.c ****     SetEN();                            /* EN = 1; EN to high for getting the busy flag  */
 336              		.loc 1 274 0
 337 0066 1E4B     		ldr	r3, .L17
 338 0068 9B69     		ldr	r3, [r3, #24]
 339 006a 181C     		mov	r0, r3
 340 006c FFF7FEFF 		bl	BitIoLdd4_SetVal
 275:../Generated_Code/LCD1.c ****     Waitns(Timing_tDDR_ns);             /* Read mode timing tDDR: time until we can read data */
 341              		.loc 1 275 0
 342 0070 FFF7FEFF 		bl	WAIT1_Wait10Cycles
 276:../Generated_Code/LCD1.c ****     ch |= DataGet();                    /* read low byte */
 343              		.loc 1 276 0
 344 0074 FFF7FEFF 		bl	DataGet
 345 0078 031C     		mov	r3, r0
 346 007a 191C     		mov	r1, r3
 347 007c FB1D     		add	r3, r7, #7
 348 007e FA1D     		add	r2, r7, #7
 349 0080 1278     		ldrb	r2, [r2]
 350 0082 0A43     		orr	r2, r1
 351 0084 1A70     		strb	r2, [r3]
 277:../Generated_Code/LCD1.c ****     Waitns(Timing_PWeh_ns-Timing_tDDR_ns); /* for accurate length of EN pulse */
 352              		.loc 1 277 0
 353 0086 FFF7FEFF 		bl	WAIT1_Wait10Cycles
 278:../Generated_Code/LCD1.c ****     ClrEN();
 354              		.loc 1 278 0
 355 008a 154B     		ldr	r3, .L17
 356 008c 9B69     		ldr	r3, [r3, #24]
 357 008e 181C     		mov	r0, r3
 358 0090 FFF7FEFF 		bl	BitIoLdd4_ClrVal
 279:../Generated_Code/LCD1.c ****     if (!(ch&BusyFlag)) {
 359              		.loc 1 279 0
 360 0094 FB1D     		add	r3, r7, #7
 361 0096 1B78     		ldrb	r3, [r3]
 362 0098 5BB2     		sxtb	r3, r3
 363 009a 002B     		cmp	r3, #0
 364 009c 02DA     		bge	.L16
 365              	.L12:
 280:../Generated_Code/LCD1.c ****       break;
 281:../Generated_Code/LCD1.c ****     }
 282:../Generated_Code/LCD1.c ****     Waitns(Timing_tCYCLE_ns-Timing_PWeh_ns); /* need to wait a cycle time until we can enable EN ag
 366              		.loc 1 282 0
 367 009e FFF7FEFF 		bl	WAIT1_Wait10Cycles
 283:../Generated_Code/LCD1.c ****   } /* for */
 368              		.loc 1 283 0
 369 00a2 C9E7     		b	.L14
 370              	.L16:
 280:../Generated_Code/LCD1.c ****       break;
 371              		.loc 1 280 0
 372 00a4 C046     		mov	r8, r8
 373              	.L15:
 284:../Generated_Code/LCD1.c ****   ClrRW();                              /* RW = 0: back to write mode */
 374              		.loc 1 284 0
 375 00a6 0E4B     		ldr	r3, .L17
 376 00a8 5B69     		ldr	r3, [r3, #20]
 377 00aa 181C     		mov	r0, r3
 378 00ac FFF7FEFF 		bl	BitIoLdd15_ClrVal
 285:../Generated_Code/LCD1.c ****   DataAsOutput();                       /* set data port as output */
 379              		.loc 1 285 0
 380 00b0 0B4B     		ldr	r3, .L17
 381 00b2 1B6A     		ldr	r3, [r3, #32]
 382 00b4 181C     		mov	r0, r3
 383 00b6 FFF7FEFF 		bl	BitIoLdd10_SetOutput
 384 00ba 094B     		ldr	r3, .L17
 385 00bc 5B6A     		ldr	r3, [r3, #36]
 386 00be 181C     		mov	r0, r3
 387 00c0 FFF7FEFF 		bl	BitIoLdd11_SetOutput
 388 00c4 064B     		ldr	r3, .L17
 389 00c6 9B6A     		ldr	r3, [r3, #40]
 390 00c8 181C     		mov	r0, r3
 391 00ca FFF7FEFF 		bl	BitIoLdd12_SetOutput
 392 00ce 044B     		ldr	r3, .L17
 393 00d0 DB6A     		ldr	r3, [r3, #44]
 394 00d2 181C     		mov	r0, r3
 395 00d4 FFF7FEFF 		bl	BitIoLdd13_SetOutput
 286:../Generated_Code/LCD1.c **** }
 396              		.loc 1 286 0
 397 00d8 BD46     		mov	sp, r7
 398 00da 02B0     		add	sp, sp, #8
 399              		@ sp needed for prologue
 400 00dc 80BD     		pop	{r7, pc}
 401              	.L18:
 402 00de C046     		.align	2
 403              	.L17:
 404 00e0 00000000 		.word	PE_LDD_DeviceDataList
 405              		.cfi_endproc
 406              	.LFE3:
 408              		.section	.text.LCD1_WriteLCDCommand,"ax",%progbits
 409              		.align	2
 410              		.global	LCD1_WriteLCDCommand
 411              		.code	16
 412              		.thumb_func
 414              	LCD1_WriteLCDCommand:
 415              	.LFB4:
 287:../Generated_Code/LCD1.c **** 
 288:../Generated_Code/LCD1.c **** /*
 289:../Generated_Code/LCD1.c **** ** ===================================================================
 290:../Generated_Code/LCD1.c **** **     Method      :  LCD1_WriteLCDCommand (component LCDHTA)
 291:../Generated_Code/LCD1.c **** **     Description :
 292:../Generated_Code/LCD1.c **** **         Writes a command to the display
 293:../Generated_Code/LCD1.c **** **     Parameters  :
 294:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 295:../Generated_Code/LCD1.c **** **         cmd             - command passed to the LCD
 296:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 297:../Generated_Code/LCD1.c **** ** ===================================================================
 298:../Generated_Code/LCD1.c **** */
 299:../Generated_Code/LCD1.c **** void LCD1_WriteLCDCommand(byte cmd)
 300:../Generated_Code/LCD1.c **** {
 416              		.loc 1 300 0
 417              		.cfi_startproc
 418 0000 80B5     		push	{r7, lr}
 419              	.LCFI11:
 420              		.cfi_def_cfa_offset 8
 421              		.cfi_offset 7, -8
 422              		.cfi_offset 14, -4
 423 0002 82B0     		sub	sp, sp, #8
 424              	.LCFI12:
 425              		.cfi_def_cfa_offset 16
 426 0004 00AF     		add	r7, sp, #0
 427              	.LCFI13:
 428              		.cfi_def_cfa_register 7
 429 0006 021C     		mov	r2, r0
 430 0008 FB1D     		add	r3, r7, #7
 431 000a 1A70     		strb	r2, [r3]
 301:../Generated_Code/LCD1.c **** #if LCD1_WAIT_DISPLAY_US > 0
 302:../Generated_Code/LCD1.c ****   WAIT1_Waitus(LCD1_WAIT_DISPLAY_US);   /* wait for some time not to write to the display while he 
 303:../Generated_Code/LCD1.c **** #endif
 304:../Generated_Code/LCD1.c ****   LCD1_WaitForLCDReady();               /* Wait until LCD is ready */
 432              		.loc 1 304 0
 433 000c FFF7FEFF 		bl	LCD1_WaitForLCDReady
 305:../Generated_Code/LCD1.c ****   /* 2 4bit transfer */
 306:../Generated_Code/LCD1.c ****   DataPut((byte)((cmd&0xF0)>>4));       /* Write the data (cycle #1) */
 434              		.loc 1 306 0
 435 0010 FB1D     		add	r3, r7, #7
 436 0012 1B78     		ldrb	r3, [r3]
 437 0014 1B09     		lsr	r3, r3, #4
 438 0016 DBB2     		uxtb	r3, r3
 439 0018 181C     		mov	r0, r3
 440 001a FFF7FEFF 		bl	DataPut
 307:../Generated_Code/LCD1.c ****   EnablePulse();                        /* transfer data */
 441              		.loc 1 307 0
 442 001e FFF7FEFF 		bl	EnablePulse
 308:../Generated_Code/LCD1.c ****   Waitus(LCD1_WAIT_LCD_CMD_AFTER_4BIT_DATA1_US);
 443              		.loc 1 308 0
 444 0022 9623     		mov	r3, #150
 445 0024 5B00     		lsl	r3, r3, #1
 446 0026 181C     		mov	r0, r3
 447 0028 FFF7FEFF 		bl	WAIT1_WaitCycles
 309:../Generated_Code/LCD1.c ****   DataPut((byte)(cmd&0x0F) );           /* Write the data (cycle #2) */
 448              		.loc 1 309 0
 449 002c FB1D     		add	r3, r7, #7
 450 002e 1A78     		ldrb	r2, [r3]
 451 0030 0F23     		mov	r3, #15
 452 0032 1340     		and	r3, r2
 453 0034 DBB2     		uxtb	r3, r3
 454 0036 181C     		mov	r0, r3
 455 0038 FFF7FEFF 		bl	DataPut
 310:../Generated_Code/LCD1.c ****   EnablePulse();                        /* do the command transfer */
 456              		.loc 1 310 0
 457 003c FFF7FEFF 		bl	EnablePulse
 311:../Generated_Code/LCD1.c ****   Waitus(LCD1_WAIT_LCD_CMD_AFTER_4BIT_DATA2_US);
 458              		.loc 1 311 0
 459 0040 9623     		mov	r3, #150
 460 0042 DB00     		lsl	r3, r3, #3
 461 0044 181C     		mov	r0, r3
 462 0046 FFF7FEFF 		bl	WAIT1_WaitCycles
 312:../Generated_Code/LCD1.c **** }
 463              		.loc 1 312 0
 464 004a BD46     		mov	sp, r7
 465 004c 02B0     		add	sp, sp, #8
 466              		@ sp needed for prologue
 467 004e 80BD     		pop	{r7, pc}
 468              		.cfi_endproc
 469              	.LFE4:
 471              		.section	.text.LCD1_Clear,"ax",%progbits
 472              		.align	2
 473              		.global	LCD1_Clear
 474              		.code	16
 475              		.thumb_func
 477              	LCD1_Clear:
 478              	.LFB5:
 313:../Generated_Code/LCD1.c **** 
 314:../Generated_Code/LCD1.c **** /*
 315:../Generated_Code/LCD1.c **** ** ===================================================================
 316:../Generated_Code/LCD1.c **** **     Method      :  LCD1_Clear (component LCDHTA)
 317:../Generated_Code/LCD1.c **** **     Description :
 318:../Generated_Code/LCD1.c **** **         Clears the display and moves the cursor to the first line.
 319:../Generated_Code/LCD1.c **** **     Parameters  : None
 320:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 321:../Generated_Code/LCD1.c **** ** ===================================================================
 322:../Generated_Code/LCD1.c **** */
 323:../Generated_Code/LCD1.c **** void LCD1_Clear(void)
 324:../Generated_Code/LCD1.c **** {
 479              		.loc 1 324 0
 480              		.cfi_startproc
 481 0000 80B5     		push	{r7, lr}
 482              	.LCFI14:
 483              		.cfi_def_cfa_offset 8
 484              		.cfi_offset 7, -8
 485              		.cfi_offset 14, -4
 486 0002 00AF     		add	r7, sp, #0
 487              	.LCFI15:
 488              		.cfi_def_cfa_register 7
 325:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(ClearDisplayCmd); /* send the clear command to the LCD */
 489              		.loc 1 325 0
 490 0004 0120     		mov	r0, #1
 491 0006 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 326:../Generated_Code/LCD1.c **** }
 492              		.loc 1 326 0
 493 000a BD46     		mov	sp, r7
 494              		@ sp needed for prologue
 495 000c 80BD     		pop	{r7, pc}
 496              		.cfi_endproc
 497              	.LFE5:
 499 000e C046     		.section	.text.LCD1_Home,"ax",%progbits
 500              		.align	2
 501              		.global	LCD1_Home
 502              		.code	16
 503              		.thumb_func
 505              	LCD1_Home:
 506              	.LFB6:
 327:../Generated_Code/LCD1.c **** 
 328:../Generated_Code/LCD1.c **** /*
 329:../Generated_Code/LCD1.c **** ** ===================================================================
 330:../Generated_Code/LCD1.c **** **     Method      :  LCD1_Home (component LCDHTA)
 331:../Generated_Code/LCD1.c **** **     Description :
 332:../Generated_Code/LCD1.c **** **         Moves the cursor to the beginning of the first line.
 333:../Generated_Code/LCD1.c **** **     Parameters  : None
 334:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 335:../Generated_Code/LCD1.c **** ** ===================================================================
 336:../Generated_Code/LCD1.c **** */
 337:../Generated_Code/LCD1.c **** void LCD1_Home(void)
 338:../Generated_Code/LCD1.c **** {
 507              		.loc 1 338 0
 508              		.cfi_startproc
 509 0000 80B5     		push	{r7, lr}
 510              	.LCFI16:
 511              		.cfi_def_cfa_offset 8
 512              		.cfi_offset 7, -8
 513              		.cfi_offset 14, -4
 514 0002 00AF     		add	r7, sp, #0
 515              	.LCFI17:
 516              		.cfi_def_cfa_register 7
 339:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(ReturnHomeCmd);  /* moves the cursor to the beginning of the first line */
 517              		.loc 1 339 0
 518 0004 0220     		mov	r0, #2
 519 0006 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 340:../Generated_Code/LCD1.c **** }
 520              		.loc 1 340 0
 521 000a BD46     		mov	sp, r7
 522              		@ sp needed for prologue
 523 000c 80BD     		pop	{r7, pc}
 524              		.cfi_endproc
 525              	.LFE6:
 527 000e C046     		.section	.text.LCD1_WriteLCDData,"ax",%progbits
 528              		.align	2
 529              		.global	LCD1_WriteLCDData
 530              		.code	16
 531              		.thumb_func
 533              	LCD1_WriteLCDData:
 534              	.LFB7:
 341:../Generated_Code/LCD1.c **** 
 342:../Generated_Code/LCD1.c **** /*
 343:../Generated_Code/LCD1.c **** ** ===================================================================
 344:../Generated_Code/LCD1.c **** **     Method      :  LCD1_WriteLCDData (component LCDHTA)
 345:../Generated_Code/LCD1.c **** **
 346:../Generated_Code/LCD1.c **** **     Description :
 347:../Generated_Code/LCD1.c **** **         Writes data to the display
 348:../Generated_Code/LCD1.c **** **         This method is internal. It is used by Processor Expert only.
 349:../Generated_Code/LCD1.c **** ** ===================================================================
 350:../Generated_Code/LCD1.c **** */
 351:../Generated_Code/LCD1.c **** void LCD1_WriteLCDData(byte ch)
 352:../Generated_Code/LCD1.c **** {
 535              		.loc 1 352 0
 536              		.cfi_startproc
 537 0000 80B5     		push	{r7, lr}
 538              	.LCFI18:
 539              		.cfi_def_cfa_offset 8
 540              		.cfi_offset 7, -8
 541              		.cfi_offset 14, -4
 542 0002 82B0     		sub	sp, sp, #8
 543              	.LCFI19:
 544              		.cfi_def_cfa_offset 16
 545 0004 00AF     		add	r7, sp, #0
 546              	.LCFI20:
 547              		.cfi_def_cfa_register 7
 548 0006 021C     		mov	r2, r0
 549 0008 FB1D     		add	r3, r7, #7
 550 000a 1A70     		strb	r2, [r3]
 353:../Generated_Code/LCD1.c **** #if LCD1_WAIT_DISPLAY_US > 0
 354:../Generated_Code/LCD1.c ****    WAIT1_Waitus(LCD1_WAIT_DISPLAY_US);  /* wait for some time not to write to the display while he 
 355:../Generated_Code/LCD1.c **** #endif
 356:../Generated_Code/LCD1.c ****    LCD1_WaitForLCDReady();              /* Wait until LCD is ready */
 551              		.loc 1 356 0
 552 000c FFF7FEFF 		bl	LCD1_WaitForLCDReady
 357:../Generated_Code/LCD1.c ****    SetRS();                             /* RS = 1: data mode */
 553              		.loc 1 357 0
 554 0010 144B     		ldr	r3, .L23
 555 0012 DB69     		ldr	r3, [r3, #28]
 556 0014 181C     		mov	r0, r3
 557 0016 FFF7FEFF 		bl	BitIoLdd5_SetVal
 358:../Generated_Code/LCD1.c ****    /* 2 4bit transfer */
 359:../Generated_Code/LCD1.c ****    DataPut((byte)((ch&0xF0)>>4));       /* Write the data (cycle #1) */
 558              		.loc 1 359 0
 559 001a FB1D     		add	r3, r7, #7
 560 001c 1B78     		ldrb	r3, [r3]
 561 001e 1B09     		lsr	r3, r3, #4
 562 0020 DBB2     		uxtb	r3, r3
 563 0022 181C     		mov	r0, r3
 564 0024 FFF7FEFF 		bl	DataPut
 360:../Generated_Code/LCD1.c ****    EnablePulse();                       /* transfer data */
 565              		.loc 1 360 0
 566 0028 FFF7FEFF 		bl	EnablePulse
 361:../Generated_Code/LCD1.c ****    Waitus(LCD1_WAIT_LCD_CMD_AFTER_4BIT_DATA1_US);
 567              		.loc 1 361 0
 568 002c 9623     		mov	r3, #150
 569 002e 5B00     		lsl	r3, r3, #1
 570 0030 181C     		mov	r0, r3
 571 0032 FFF7FEFF 		bl	WAIT1_WaitCycles
 362:../Generated_Code/LCD1.c ****    DataPut((byte)(ch&0x0F));            /* Write the data (cycle #2) */
 572              		.loc 1 362 0
 573 0036 FB1D     		add	r3, r7, #7
 574 0038 1A78     		ldrb	r2, [r3]
 575 003a 0F23     		mov	r3, #15
 576 003c 1340     		and	r3, r2
 577 003e DBB2     		uxtb	r3, r3
 578 0040 181C     		mov	r0, r3
 579 0042 FFF7FEFF 		bl	DataPut
 363:../Generated_Code/LCD1.c ****    EnablePulse();                       /* do the command transfer */
 580              		.loc 1 363 0
 581 0046 FFF7FEFF 		bl	EnablePulse
 364:../Generated_Code/LCD1.c ****    Waitus(LCD1_WAIT_LCD_CMD_AFTER_4BIT_DATA2_US);
 582              		.loc 1 364 0
 583 004a 9623     		mov	r3, #150
 584 004c DB00     		lsl	r3, r3, #3
 585 004e 181C     		mov	r0, r3
 586 0050 FFF7FEFF 		bl	WAIT1_WaitCycles
 365:../Generated_Code/LCD1.c ****    ClrRS();                             /* RS = 0: back to command mode */
 587              		.loc 1 365 0
 588 0054 034B     		ldr	r3, .L23
 589 0056 DB69     		ldr	r3, [r3, #28]
 590 0058 181C     		mov	r0, r3
 591 005a FFF7FEFF 		bl	BitIoLdd5_ClrVal
 366:../Generated_Code/LCD1.c **** }
 592              		.loc 1 366 0
 593 005e BD46     		mov	sp, r7
 594 0060 02B0     		add	sp, sp, #8
 595              		@ sp needed for prologue
 596 0062 80BD     		pop	{r7, pc}
 597              	.L24:
 598              		.align	2
 599              	.L23:
 600 0064 00000000 		.word	PE_LDD_DeviceDataList
 601              		.cfi_endproc
 602              	.LFE7:
 604              		.section	.text.LCD1_GotoXY,"ax",%progbits
 605              		.align	2
 606              		.global	LCD1_GotoXY
 607              		.code	16
 608              		.thumb_func
 610              	LCD1_GotoXY:
 611              	.LFB8:
 367:../Generated_Code/LCD1.c **** 
 368:../Generated_Code/LCD1.c **** /*
 369:../Generated_Code/LCD1.c **** ** ===================================================================
 370:../Generated_Code/LCD1.c **** **     Method      :  LCD1_GotoXY (component LCDHTA)
 371:../Generated_Code/LCD1.c **** **     Description :
 372:../Generated_Code/LCD1.c **** **         Places the cursor on a specified position on the display.
 373:../Generated_Code/LCD1.c **** **     Parameters  :
 374:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 375:../Generated_Code/LCD1.c **** **         line            - Line number starting with 1
 376:../Generated_Code/LCD1.c **** **         column          - Column number starting with 1
 377:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 378:../Generated_Code/LCD1.c **** ** ===================================================================
 379:../Generated_Code/LCD1.c **** */
 380:../Generated_Code/LCD1.c **** void LCD1_GotoXY(byte line, byte column)
 381:../Generated_Code/LCD1.c **** {
 612              		.loc 1 381 0
 613              		.cfi_startproc
 614 0000 80B5     		push	{r7, lr}
 615              	.LCFI21:
 616              		.cfi_def_cfa_offset 8
 617              		.cfi_offset 7, -8
 618              		.cfi_offset 14, -4
 619 0002 82B0     		sub	sp, sp, #8
 620              	.LCFI22:
 621              		.cfi_def_cfa_offset 16
 622 0004 00AF     		add	r7, sp, #0
 623              	.LCFI23:
 624              		.cfi_def_cfa_register 7
 625 0006 0A1C     		mov	r2, r1
 626 0008 FB1D     		add	r3, r7, #7
 627 000a 011C     		add	r1, r0, #0
 628 000c 1970     		strb	r1, [r3]
 629 000e BB1D     		add	r3, r7, #6
 630 0010 1A70     		strb	r2, [r3]
 382:../Generated_Code/LCD1.c **** /* row is in the range 1..LCD_Nof_Lines and column in the range 1..LCD_Nof_Columns */
 383:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand((byte)(GotoXYCmd + (column-1) + (line==1 ? 0x00:Line2Offset)));
 631              		.loc 1 383 0
 632 0012 FB1D     		add	r3, r7, #7
 633 0014 1B78     		ldrb	r3, [r3]
 634 0016 012B     		cmp	r3, #1
 635 0018 01D1     		bne	.L26
 636              		.loc 1 383 0 is_stmt 0
 637 001a 0023     		mov	r3, #0
 638 001c 00E0     		b	.L27
 639              	.L26:
 640              		.loc 1 383 0
 641 001e 4023     		mov	r3, #64
 642              	.L27:
 643              		.loc 1 383 0
 644 0020 BA1D     		add	r2, r7, #6
 645 0022 1278     		ldrb	r2, [r2]
 646 0024 9B18     		add	r3, r3, r2
 647 0026 DBB2     		uxtb	r3, r3
 648 0028 7F33     		add	r3, r3, #127
 649 002a DBB2     		uxtb	r3, r3
 650 002c 181C     		mov	r0, r3
 651 002e FFF7FEFF 		bl	LCD1_WriteLCDCommand
 384:../Generated_Code/LCD1.c **** }
 652              		.loc 1 384 0 is_stmt 1
 653 0032 BD46     		mov	sp, r7
 654 0034 02B0     		add	sp, sp, #8
 655              		@ sp needed for prologue
 656 0036 80BD     		pop	{r7, pc}
 657              		.cfi_endproc
 658              	.LFE8:
 660              		.section	.text.LCD1_ShiftLeft,"ax",%progbits
 661              		.align	2
 662              		.global	LCD1_ShiftLeft
 663              		.code	16
 664              		.thumb_func
 666              	LCD1_ShiftLeft:
 667              	.LFB9:
 385:../Generated_Code/LCD1.c **** 
 386:../Generated_Code/LCD1.c **** /*
 387:../Generated_Code/LCD1.c **** ** ===================================================================
 388:../Generated_Code/LCD1.c **** **     Method      :  LCD1_ShiftLeft (component LCDHTA)
 389:../Generated_Code/LCD1.c **** **     Description :
 390:../Generated_Code/LCD1.c **** **         Shifts all characters to the left.
 391:../Generated_Code/LCD1.c **** **     Parameters  : None
 392:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 393:../Generated_Code/LCD1.c **** ** ===================================================================
 394:../Generated_Code/LCD1.c **** */
 395:../Generated_Code/LCD1.c **** void LCD1_ShiftLeft(void)
 396:../Generated_Code/LCD1.c **** {
 668              		.loc 1 396 0
 669              		.cfi_startproc
 670 0000 80B5     		push	{r7, lr}
 671              	.LCFI24:
 672              		.cfi_def_cfa_offset 8
 673              		.cfi_offset 7, -8
 674              		.cfi_offset 14, -4
 675 0002 00AF     		add	r7, sp, #0
 676              	.LCFI25:
 677              		.cfi_def_cfa_register 7
 397:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(LeftShiftCmd);
 678              		.loc 1 397 0
 679 0004 1820     		mov	r0, #24
 680 0006 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 398:../Generated_Code/LCD1.c **** }
 681              		.loc 1 398 0
 682 000a BD46     		mov	sp, r7
 683              		@ sp needed for prologue
 684 000c 80BD     		pop	{r7, pc}
 685              		.cfi_endproc
 686              	.LFE9:
 688 000e C046     		.section	.text.LCD1_WriteLn,"ax",%progbits
 689              		.align	2
 690              		.global	LCD1_WriteLn
 691              		.code	16
 692              		.thumb_func
 694              	LCD1_WriteLn:
 695              	.LFB10:
 399:../Generated_Code/LCD1.c **** 
 400:../Generated_Code/LCD1.c **** /*
 401:../Generated_Code/LCD1.c **** ** ===================================================================
 402:../Generated_Code/LCD1.c **** **     Method      :  LCD1_Write (component LCDHTA)
 403:../Generated_Code/LCD1.c **** **     Description :
 404:../Generated_Code/LCD1.c **** **         Write a single character to the display
 405:../Generated_Code/LCD1.c **** **     Parameters  :
 406:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 407:../Generated_Code/LCD1.c **** **         ch              - Character to write
 408:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 409:../Generated_Code/LCD1.c **** ** ===================================================================
 410:../Generated_Code/LCD1.c **** */
 411:../Generated_Code/LCD1.c **** /* The method is implemented as a macro, see LCD1.h */
 412:../Generated_Code/LCD1.c **** /*
 413:../Generated_Code/LCD1.c **** ** ===================================================================
 414:../Generated_Code/LCD1.c **** **     Method      :  LCD1_WriteLn (component LCDHTA)
 415:../Generated_Code/LCD1.c **** **     Description :
 416:../Generated_Code/LCD1.c **** **         Writes a new line to the display
 417:../Generated_Code/LCD1.c **** **     Parameters  : None
 418:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 419:../Generated_Code/LCD1.c **** ** ===================================================================
 420:../Generated_Code/LCD1.c **** */
 421:../Generated_Code/LCD1.c **** void LCD1_WriteLn(void)
 422:../Generated_Code/LCD1.c **** {
 696              		.loc 1 422 0
 697              		.cfi_startproc
 698 0000 80B5     		push	{r7, lr}
 699              	.LCFI26:
 700              		.cfi_def_cfa_offset 8
 701              		.cfi_offset 7, -8
 702              		.cfi_offset 14, -4
 703 0002 00AF     		add	r7, sp, #0
 704              	.LCFI27:
 705              		.cfi_def_cfa_register 7
 423:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(SecondLineCmd);
 706              		.loc 1 423 0
 707 0004 C020     		mov	r0, #192
 708 0006 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 424:../Generated_Code/LCD1.c **** }
 709              		.loc 1 424 0
 710 000a BD46     		mov	sp, r7
 711              		@ sp needed for prologue
 712 000c 80BD     		pop	{r7, pc}
 713              		.cfi_endproc
 714              	.LFE10:
 716 000e C046     		.section	.text.LCD1_WriteString,"ax",%progbits
 717              		.align	2
 718              		.global	LCD1_WriteString
 719              		.code	16
 720              		.thumb_func
 722              	LCD1_WriteString:
 723              	.LFB11:
 425:../Generated_Code/LCD1.c **** 
 426:../Generated_Code/LCD1.c **** /*
 427:../Generated_Code/LCD1.c **** ** ===================================================================
 428:../Generated_Code/LCD1.c **** **     Method      :  LCD1_WriteString (component LCDHTA)
 429:../Generated_Code/LCD1.c **** **     Description :
 430:../Generated_Code/LCD1.c **** **         Writes a string to the display at the current cursor
 431:../Generated_Code/LCD1.c **** **         position.
 432:../Generated_Code/LCD1.c **** **     Parameters  :
 433:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 434:../Generated_Code/LCD1.c **** **       * str             - Pointer to string (zero byte terminated)
 435:../Generated_Code/LCD1.c **** **                           to write to the display
 436:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 437:../Generated_Code/LCD1.c **** ** ===================================================================
 438:../Generated_Code/LCD1.c **** */
 439:../Generated_Code/LCD1.c **** void LCD1_WriteString(char *str)
 440:../Generated_Code/LCD1.c **** {
 724              		.loc 1 440 0
 725              		.cfi_startproc
 726 0000 80B5     		push	{r7, lr}
 727              	.LCFI28:
 728              		.cfi_def_cfa_offset 8
 729              		.cfi_offset 7, -8
 730              		.cfi_offset 14, -4
 731 0002 82B0     		sub	sp, sp, #8
 732              	.LCFI29:
 733              		.cfi_def_cfa_offset 16
 734 0004 00AF     		add	r7, sp, #0
 735              	.LCFI30:
 736              		.cfi_def_cfa_register 7
 737 0006 7860     		str	r0, [r7, #4]
 441:../Generated_Code/LCD1.c ****   while (*str != '\0'){
 738              		.loc 1 441 0
 739 0008 07E0     		b	.L31
 740              	.L32:
 442:../Generated_Code/LCD1.c ****     LCD1_Write(*str);
 741              		.loc 1 442 0
 742 000a 7B68     		ldr	r3, [r7, #4]
 743 000c 1B78     		ldrb	r3, [r3]
 744 000e 181C     		mov	r0, r3
 745 0010 FFF7FEFF 		bl	LCD1_WriteLCDData
 443:../Generated_Code/LCD1.c ****     str++;
 746              		.loc 1 443 0
 747 0014 7B68     		ldr	r3, [r7, #4]
 748 0016 0133     		add	r3, r3, #1
 749 0018 7B60     		str	r3, [r7, #4]
 750              	.L31:
 441:../Generated_Code/LCD1.c ****   while (*str != '\0'){
 751              		.loc 1 441 0
 752 001a 7B68     		ldr	r3, [r7, #4]
 753 001c 1B78     		ldrb	r3, [r3]
 754 001e 002B     		cmp	r3, #0
 755 0020 F3D1     		bne	.L32
 444:../Generated_Code/LCD1.c ****   }
 445:../Generated_Code/LCD1.c **** }
 756              		.loc 1 445 0
 757 0022 BD46     		mov	sp, r7
 758 0024 02B0     		add	sp, sp, #8
 759              		@ sp needed for prologue
 760 0026 80BD     		pop	{r7, pc}
 761              		.cfi_endproc
 762              	.LFE11:
 764              		.section	.text.LCD1_WriteLineStr,"ax",%progbits
 765              		.align	2
 766              		.global	LCD1_WriteLineStr
 767              		.code	16
 768              		.thumb_func
 770              	LCD1_WriteLineStr:
 771              	.LFB12:
 446:../Generated_Code/LCD1.c **** 
 447:../Generated_Code/LCD1.c **** /*
 448:../Generated_Code/LCD1.c **** ** ===================================================================
 449:../Generated_Code/LCD1.c **** **     Method      :  LCD1_WriteLineStr (component LCDHTA)
 450:../Generated_Code/LCD1.c **** **     Description :
 451:../Generated_Code/LCD1.c **** **         Writes a full line to the display (clears the rest of the
 452:../Generated_Code/LCD1.c **** **         line).
 453:../Generated_Code/LCD1.c **** **     Parameters  :
 454:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 455:../Generated_Code/LCD1.c **** **         line            - Line number (starting with 1).
 456:../Generated_Code/LCD1.c **** **       * str             - Pointer to the string which should be
 457:../Generated_Code/LCD1.c **** **                           shown on the display.
 458:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 459:../Generated_Code/LCD1.c **** ** ===================================================================
 460:../Generated_Code/LCD1.c **** */
 461:../Generated_Code/LCD1.c **** void LCD1_WriteLineStr(byte line, char *str)
 462:../Generated_Code/LCD1.c **** {
 772              		.loc 1 462 0
 773              		.cfi_startproc
 774 0000 80B5     		push	{r7, lr}
 775              	.LCFI31:
 776              		.cfi_def_cfa_offset 8
 777              		.cfi_offset 7, -8
 778              		.cfi_offset 14, -4
 779 0002 84B0     		sub	sp, sp, #16
 780              	.LCFI32:
 781              		.cfi_def_cfa_offset 24
 782 0004 00AF     		add	r7, sp, #0
 783              	.LCFI33:
 784              		.cfi_def_cfa_register 7
 785 0006 021C     		mov	r2, r0
 786 0008 3960     		str	r1, [r7]
 787 000a FB1D     		add	r3, r7, #7
 788 000c 1A70     		strb	r2, [r3]
 463:../Generated_Code/LCD1.c ****   byte i;
 464:../Generated_Code/LCD1.c **** 
 465:../Generated_Code/LCD1.c ****   LCD1_Line(line);                      /* select line */
 789              		.loc 1 465 0
 790 000e FB1D     		add	r3, r7, #7
 791 0010 1B78     		ldrb	r3, [r3]
 792 0012 181C     		mov	r0, r3
 793 0014 FFF7FEFF 		bl	LCD1_Line
 466:../Generated_Code/LCD1.c ****   for(i = 0; i < LCD1_MAX_LCD_LINE_CHARS && *str!='\0'; i++, str++) {
 794              		.loc 1 466 0
 795 0018 3B1C     		mov	r3, r7
 796 001a 0F33     		add	r3, r3, #15
 797 001c 0022     		mov	r2, #0
 798 001e 1A70     		strb	r2, [r3]
 799 0020 0EE0     		b	.L34
 800              	.L36:
 467:../Generated_Code/LCD1.c ****     LCD1_Write(*str);
 801              		.loc 1 467 0
 802 0022 3B68     		ldr	r3, [r7]
 803 0024 1B78     		ldrb	r3, [r3]
 804 0026 181C     		mov	r0, r3
 805 0028 FFF7FEFF 		bl	LCD1_WriteLCDData
 466:../Generated_Code/LCD1.c ****   for(i = 0; i < LCD1_MAX_LCD_LINE_CHARS && *str!='\0'; i++, str++) {
 806              		.loc 1 466 0
 807 002c 3B1C     		mov	r3, r7
 808 002e 0F33     		add	r3, r3, #15
 809 0030 3A1C     		mov	r2, r7
 810 0032 0F32     		add	r2, r2, #15
 811 0034 1278     		ldrb	r2, [r2]
 812 0036 0132     		add	r2, r2, #1
 813 0038 1A70     		strb	r2, [r3]
 814 003a 3B68     		ldr	r3, [r7]
 815 003c 0133     		add	r3, r3, #1
 816 003e 3B60     		str	r3, [r7]
 817              	.L34:
 818 0040 3B1C     		mov	r3, r7
 819 0042 0F33     		add	r3, r3, #15
 820 0044 1B78     		ldrb	r3, [r3]
 821 0046 0F2B     		cmp	r3, #15
 822 0048 0ED8     		bhi	.L37
 466:../Generated_Code/LCD1.c ****   for(i = 0; i < LCD1_MAX_LCD_LINE_CHARS && *str!='\0'; i++, str++) {
 823              		.loc 1 466 0 is_stmt 0
 824 004a 3B68     		ldr	r3, [r7]
 825 004c 1B78     		ldrb	r3, [r3]
 826 004e 002B     		cmp	r3, #0
 827 0050 E7D1     		bne	.L36
 468:../Generated_Code/LCD1.c ****   }
 469:../Generated_Code/LCD1.c ****   /* Clear the rest of the line */
 470:../Generated_Code/LCD1.c ****   for (; i < LCD1_MAX_LCD_LINE_CHARS; i++) {
 828              		.loc 1 470 0 is_stmt 1
 829 0052 09E0     		b	.L37
 830              	.L38:
 471:../Generated_Code/LCD1.c ****     LCD1_Write(' ');
 831              		.loc 1 471 0
 832 0054 2020     		mov	r0, #32
 833 0056 FFF7FEFF 		bl	LCD1_WriteLCDData
 470:../Generated_Code/LCD1.c ****   for (; i < LCD1_MAX_LCD_LINE_CHARS; i++) {
 834              		.loc 1 470 0
 835 005a 3B1C     		mov	r3, r7
 836 005c 0F33     		add	r3, r3, #15
 837 005e 3A1C     		mov	r2, r7
 838 0060 0F32     		add	r2, r2, #15
 839 0062 1278     		ldrb	r2, [r2]
 840 0064 0132     		add	r2, r2, #1
 841 0066 1A70     		strb	r2, [r3]
 842              	.L37:
 470:../Generated_Code/LCD1.c ****   for (; i < LCD1_MAX_LCD_LINE_CHARS; i++) {
 843              		.loc 1 470 0 is_stmt 0
 844 0068 3B1C     		mov	r3, r7
 845 006a 0F33     		add	r3, r3, #15
 846 006c 1B78     		ldrb	r3, [r3]
 847 006e 0F2B     		cmp	r3, #15
 848 0070 F0D9     		bls	.L38
 472:../Generated_Code/LCD1.c ****   }
 473:../Generated_Code/LCD1.c **** }
 849              		.loc 1 473 0 is_stmt 1
 850 0072 BD46     		mov	sp, r7
 851 0074 04B0     		add	sp, sp, #16
 852              		@ sp needed for prologue
 853 0076 80BD     		pop	{r7, pc}
 854              		.cfi_endproc
 855              	.LFE12:
 857              		.section	.text.LCD1_Line,"ax",%progbits
 858              		.align	2
 859              		.global	LCD1_Line
 860              		.code	16
 861              		.thumb_func
 863              	LCD1_Line:
 864              	.LFB13:
 474:../Generated_Code/LCD1.c **** 
 475:../Generated_Code/LCD1.c **** /*
 476:../Generated_Code/LCD1.c **** ** ===================================================================
 477:../Generated_Code/LCD1.c **** **     Method      :  LCD1_Line (component LCDHTA)
 478:../Generated_Code/LCD1.c **** **     Description :
 479:../Generated_Code/LCD1.c **** **         Sets the current line.
 480:../Generated_Code/LCD1.c **** **     Parameters  :
 481:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 482:../Generated_Code/LCD1.c **** **         line            - Line number, starting with 1
 483:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 484:../Generated_Code/LCD1.c **** ** ===================================================================
 485:../Generated_Code/LCD1.c **** */
 486:../Generated_Code/LCD1.c **** void LCD1_Line(byte line)
 487:../Generated_Code/LCD1.c **** {
 865              		.loc 1 487 0
 866              		.cfi_startproc
 867 0000 80B5     		push	{r7, lr}
 868              	.LCFI34:
 869              		.cfi_def_cfa_offset 8
 870              		.cfi_offset 7, -8
 871              		.cfi_offset 14, -4
 872 0002 82B0     		sub	sp, sp, #8
 873              	.LCFI35:
 874              		.cfi_def_cfa_offset 16
 875 0004 00AF     		add	r7, sp, #0
 876              	.LCFI36:
 877              		.cfi_def_cfa_register 7
 878 0006 021C     		mov	r2, r0
 879 0008 FB1D     		add	r3, r7, #7
 880 000a 1A70     		strb	r2, [r3]
 488:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand((byte)(line==1?FirstLineCmd:SecondLineCmd));
 881              		.loc 1 488 0
 882 000c FB1D     		add	r3, r7, #7
 883 000e 1B78     		ldrb	r3, [r3]
 884 0010 012B     		cmp	r3, #1
 885 0012 01D1     		bne	.L40
 886              		.loc 1 488 0 is_stmt 0
 887 0014 8023     		mov	r3, #128
 888 0016 00E0     		b	.L41
 889              	.L40:
 890              		.loc 1 488 0
 891 0018 C023     		mov	r3, #192
 892              	.L41:
 893              		.loc 1 488 0
 894 001a 181C     		mov	r0, r3
 895 001c FFF7FEFF 		bl	LCD1_WriteLCDCommand
 489:../Generated_Code/LCD1.c **** }
 896              		.loc 1 489 0 is_stmt 1
 897 0020 BD46     		mov	sp, r7
 898 0022 02B0     		add	sp, sp, #8
 899              		@ sp needed for prologue
 900 0024 80BD     		pop	{r7, pc}
 901              		.cfi_endproc
 902              	.LFE13:
 904 0026 C046     		.section	.text.LCD1_Init,"ax",%progbits
 905              		.align	2
 906              		.global	LCD1_Init
 907              		.code	16
 908              		.thumb_func
 910              	LCD1_Init:
 911              	.LFB14:
 490:../Generated_Code/LCD1.c **** 
 491:../Generated_Code/LCD1.c **** /*
 492:../Generated_Code/LCD1.c **** ** ===================================================================
 493:../Generated_Code/LCD1.c **** **     Method      :  LCD1_Init (component LCDHTA)
 494:../Generated_Code/LCD1.c **** **
 495:../Generated_Code/LCD1.c **** **     Description :
 496:../Generated_Code/LCD1.c **** **         Display driver initialization routine.
 497:../Generated_Code/LCD1.c **** **         This method is internal. It is used by Processor Expert only.
 498:../Generated_Code/LCD1.c **** ** ===================================================================
 499:../Generated_Code/LCD1.c **** */
 500:../Generated_Code/LCD1.c **** void LCD1_Init(void)
 501:../Generated_Code/LCD1.c **** {
 912              		.loc 1 501 0
 913              		.cfi_startproc
 914 0000 80B5     		push	{r7, lr}
 915              	.LCFI37:
 916              		.cfi_def_cfa_offset 8
 917              		.cfi_offset 7, -8
 918              		.cfi_offset 14, -4
 919 0002 00AF     		add	r7, sp, #0
 920              	.LCFI38:
 921              		.cfi_def_cfa_register 7
 502:../Generated_Code/LCD1.c ****   /* This function initializes the driver.
 503:../Generated_Code/LCD1.c ****      The low level init already shall have set our data port to input/output, currently set to outp
 504:../Generated_Code/LCD1.c ****      plus all control pins are set as outputs with low values. To be sure, we do it here again. */
 505:../Generated_Code/LCD1.c ****   ClrEN();                              /* EN Pin low */
 922              		.loc 1 505 0
 923 0004 2B4B     		ldr	r3, .L43
 924 0006 9B69     		ldr	r3, [r3, #24]
 925 0008 181C     		mov	r0, r3
 926 000a FFF7FEFF 		bl	BitIoLdd4_ClrVal
 506:../Generated_Code/LCD1.c ****   ClrRW();                              /* RW Pin low */
 927              		.loc 1 506 0
 928 000e 294B     		ldr	r3, .L43
 929 0010 5B69     		ldr	r3, [r3, #20]
 930 0012 181C     		mov	r0, r3
 931 0014 FFF7FEFF 		bl	BitIoLdd15_ClrVal
 507:../Generated_Code/LCD1.c ****   ClrRS();                              /* RS Pin low: command mode */
 932              		.loc 1 507 0
 933 0018 264B     		ldr	r3, .L43
 934 001a DB69     		ldr	r3, [r3, #28]
 935 001c 181C     		mov	r0, r3
 936 001e FFF7FEFF 		bl	BitIoLdd5_ClrVal
 508:../Generated_Code/LCD1.c ****   DataPut(0);
 937              		.loc 1 508 0
 938 0022 0020     		mov	r0, #0
 939 0024 FFF7FEFF 		bl	DataPut
 509:../Generated_Code/LCD1.c **** 
 510:../Generated_Code/LCD1.c ****   /* make pins output */
 511:../Generated_Code/LCD1.c ****   DataAsOutput();
 940              		.loc 1 511 0
 941 0028 224B     		ldr	r3, .L43
 942 002a 1B6A     		ldr	r3, [r3, #32]
 943 002c 181C     		mov	r0, r3
 944 002e FFF7FEFF 		bl	BitIoLdd10_SetOutput
 945 0032 204B     		ldr	r3, .L43
 946 0034 5B6A     		ldr	r3, [r3, #36]
 947 0036 181C     		mov	r0, r3
 948 0038 FFF7FEFF 		bl	BitIoLdd11_SetOutput
 949 003c 1D4B     		ldr	r3, .L43
 950 003e 9B6A     		ldr	r3, [r3, #40]
 951 0040 181C     		mov	r0, r3
 952 0042 FFF7FEFF 		bl	BitIoLdd12_SetOutput
 953 0046 1B4B     		ldr	r3, .L43
 954 0048 DB6A     		ldr	r3, [r3, #44]
 955 004a 181C     		mov	r0, r3
 956 004c FFF7FEFF 		bl	BitIoLdd13_SetOutput
 512:../Generated_Code/LCD1.c **** 
 513:../Generated_Code/LCD1.c ****   /* send the reset sequence according to the data sheet */
 514:../Generated_Code/LCD1.c ****   Waitms(80);                           /* wait for more than 15ms after Vcc rises to 4.5V, wait fo
 957              		.loc 1 514 0
 958 0050 5020     		mov	r0, #80
 959 0052 FFF7FEFF 		bl	WAIT1_Waitms
 515:../Generated_Code/LCD1.c ****   DataPut(0x3);                         /* BF cannot be checked before this function, function set 
 960              		.loc 1 515 0
 961 0056 0320     		mov	r0, #3
 962 0058 FFF7FEFF 		bl	DataPut
 516:../Generated_Code/LCD1.c ****   EnablePulse();                        /* transfer data */
 963              		.loc 1 516 0
 964 005c FFF7FEFF 		bl	EnablePulse
 517:../Generated_Code/LCD1.c ****   Waitms(5);                            /* wait for more than 4.1 ms */
 965              		.loc 1 517 0
 966 0060 0520     		mov	r0, #5
 967 0062 FFF7FEFF 		bl	WAIT1_Waitms
 518:../Generated_Code/LCD1.c ****   /* 0x3 is already on the bus from previous DataPut(), do not need to put it again here */
 519:../Generated_Code/LCD1.c ****   EnablePulse();                        /* transfer data */
 968              		.loc 1 519 0
 969 0066 FFF7FEFF 		bl	EnablePulse
 520:../Generated_Code/LCD1.c ****   Waitus(100);                          /* wait for more than 100us */
 970              		.loc 1 520 0
 971 006a FA23     		mov	r3, #250
 972 006c DB00     		lsl	r3, r3, #3
 973 006e 181C     		mov	r0, r3
 974 0070 FFF7FEFF 		bl	WAIT1_WaitCycles
 521:../Generated_Code/LCD1.c ****   /* 0x3 is already on the bus from previous DataPut(), do not need to put it again here */
 522:../Generated_Code/LCD1.c ****   EnablePulse();                        /* transfer data */
 975              		.loc 1 522 0
 976 0074 FFF7FEFF 		bl	EnablePulse
 523:../Generated_Code/LCD1.c ****   Waitus(100);                          /* wait for more than 100us */
 977              		.loc 1 523 0
 978 0078 FA23     		mov	r3, #250
 979 007a DB00     		lsl	r3, r3, #3
 980 007c 181C     		mov	r0, r3
 981 007e FFF7FEFF 		bl	WAIT1_WaitCycles
 524:../Generated_Code/LCD1.c **** 
 525:../Generated_Code/LCD1.c ****   DataPut(0x2);                         /* Function set */
 982              		.loc 1 525 0
 983 0082 0220     		mov	r0, #2
 984 0084 FFF7FEFF 		bl	DataPut
 526:../Generated_Code/LCD1.c ****   EnablePulse();                        /* transfer data */
 985              		.loc 1 526 0
 986 0088 FFF7FEFF 		bl	EnablePulse
 527:../Generated_Code/LCD1.c ****   Waitus(100);
 987              		.loc 1 527 0
 988 008c FA23     		mov	r3, #250
 989 008e DB00     		lsl	r3, r3, #3
 990 0090 181C     		mov	r0, r3
 991 0092 FFF7FEFF 		bl	WAIT1_WaitCycles
 528:../Generated_Code/LCD1.c **** 
 529:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(FunctionSetCmd|FunctionSet_Font5x8
 992              		.loc 1 529 0
 993 0096 2820     		mov	r0, #40
 994 0098 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 530:../Generated_Code/LCD1.c ****                  |FunctionSet_4bit      /* we are using 4bit data bus */ \
 531:../Generated_Code/LCD1.c ****                  |FunctionSet_2Lines    /* we are using two or more lines */
 532:../Generated_Code/LCD1.c ****                  );
 533:../Generated_Code/LCD1.c **** 
 534:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(DisplayOnOffControlCmd|DisplayOnOffControl_DisplayOn);
 995              		.loc 1 534 0
 996 009c 0C20     		mov	r0, #12
 997 009e FFF7FEFF 		bl	LCD1_WriteLCDCommand
 535:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(ClearDisplayCmd); /* Clear display */
 998              		.loc 1 535 0
 999 00a2 0120     		mov	r0, #1
 1000 00a4 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 536:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(EntryModeSetCmd|EntryModeSet_IncrementOn); /* Entry mode set: Increment mode
 1001              		.loc 1 536 0
 1002 00a8 0620     		mov	r0, #6
 1003 00aa FFF7FEFF 		bl	LCD1_WriteLCDCommand
 537:../Generated_Code/LCD1.c **** }
 1004              		.loc 1 537 0
 1005 00ae BD46     		mov	sp, r7
 1006              		@ sp needed for prologue
 1007 00b0 80BD     		pop	{r7, pc}
 1008              	.L44:
 1009 00b2 C046     		.align	2
 1010              	.L43:
 1011 00b4 00000000 		.word	PE_LDD_DeviceDataList
 1012              		.cfi_endproc
 1013              	.LFE14:
 1015              		.section	.text.LCD1_ShiftRight,"ax",%progbits
 1016              		.align	2
 1017              		.global	LCD1_ShiftRight
 1018              		.code	16
 1019              		.thumb_func
 1021              	LCD1_ShiftRight:
 1022              	.LFB15:
 538:../Generated_Code/LCD1.c **** 
 539:../Generated_Code/LCD1.c **** /*
 540:../Generated_Code/LCD1.c **** ** ===================================================================
 541:../Generated_Code/LCD1.c **** **     Method      :  LCD1_ShiftRight (component LCDHTA)
 542:../Generated_Code/LCD1.c **** **     Description :
 543:../Generated_Code/LCD1.c **** **         Shifts all characters to the right.
 544:../Generated_Code/LCD1.c **** **     Parameters  : None
 545:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 546:../Generated_Code/LCD1.c **** ** ===================================================================
 547:../Generated_Code/LCD1.c **** */
 548:../Generated_Code/LCD1.c **** void LCD1_ShiftRight(void)
 549:../Generated_Code/LCD1.c **** {
 1023              		.loc 1 549 0
 1024              		.cfi_startproc
 1025 0000 80B5     		push	{r7, lr}
 1026              	.LCFI39:
 1027              		.cfi_def_cfa_offset 8
 1028              		.cfi_offset 7, -8
 1029              		.cfi_offset 14, -4
 1030 0002 00AF     		add	r7, sp, #0
 1031              	.LCFI40:
 1032              		.cfi_def_cfa_register 7
 550:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(RightShiftCmd);
 1033              		.loc 1 550 0
 1034 0004 1C20     		mov	r0, #28
 1035 0006 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 551:../Generated_Code/LCD1.c **** }
 1036              		.loc 1 551 0
 1037 000a BD46     		mov	sp, r7
 1038              		@ sp needed for prologue
 1039 000c 80BD     		pop	{r7, pc}
 1040              		.cfi_endproc
 1041              	.LFE15:
 1043 000e C046     		.section	.text.LCD1_SetEntryMode,"ax",%progbits
 1044              		.align	2
 1045              		.global	LCD1_SetEntryMode
 1046              		.code	16
 1047              		.thumb_func
 1049              	LCD1_SetEntryMode:
 1050              	.LFB16:
 552:../Generated_Code/LCD1.c **** 
 553:../Generated_Code/LCD1.c **** /*
 554:../Generated_Code/LCD1.c **** ** ===================================================================
 555:../Generated_Code/LCD1.c **** **     Method      :  LCD1_SetEntryMode (component LCDHTA)
 556:../Generated_Code/LCD1.c **** **     Description :
 557:../Generated_Code/LCD1.c **** **         Configures the display entry mode, if the cursor has to
 558:../Generated_Code/LCD1.c **** **         shift and/or if the display shall shift content while
 559:../Generated_Code/LCD1.c **** **         displaying text.
 560:../Generated_Code/LCD1.c **** **     Parameters  :
 561:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 562:../Generated_Code/LCD1.c **** **         increment       - Increments (TRUE) or
 563:../Generated_Code/LCD1.c **** **                           decrements (FALSE) the display address by 1
 564:../Generated_Code/LCD1.c **** **                           when a character code is written into or
 565:../Generated_Code/LCD1.c **** **                           read from DDRAM. The cursor or blinking
 566:../Generated_Code/LCD1.c **** **                           moves to the right when incremented by 1
 567:../Generated_Code/LCD1.c **** **                           and to the left when decremented by 1.
 568:../Generated_Code/LCD1.c **** **         shiftLeft       - The display does not shift if
 569:../Generated_Code/LCD1.c **** **                           the 'shift' is FALSE. If 'shift' is TRUE,
 570:../Generated_Code/LCD1.c **** **                           it will seem as if the cursor does not move
 571:../Generated_Code/LCD1.c **** **                           but the display does.
 572:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 573:../Generated_Code/LCD1.c **** ** ===================================================================
 574:../Generated_Code/LCD1.c **** */
 575:../Generated_Code/LCD1.c **** void LCD1_SetEntryMode(bool increment, bool shiftLeft)
 576:../Generated_Code/LCD1.c **** {
 1051              		.loc 1 576 0
 1052              		.cfi_startproc
 1053 0000 80B5     		push	{r7, lr}
 1054              	.LCFI41:
 1055              		.cfi_def_cfa_offset 8
 1056              		.cfi_offset 7, -8
 1057              		.cfi_offset 14, -4
 1058 0002 84B0     		sub	sp, sp, #16
 1059              	.LCFI42:
 1060              		.cfi_def_cfa_offset 24
 1061 0004 00AF     		add	r7, sp, #0
 1062              	.LCFI43:
 1063              		.cfi_def_cfa_register 7
 1064 0006 0A1C     		mov	r2, r1
 1065 0008 FB1D     		add	r3, r7, #7
 1066 000a 011C     		add	r1, r0, #0
 1067 000c 1970     		strb	r1, [r3]
 1068 000e BB1D     		add	r3, r7, #6
 1069 0010 1A70     		strb	r2, [r3]
 577:../Generated_Code/LCD1.c ****   byte flags = 0;
 1070              		.loc 1 577 0
 1071 0012 3B1C     		mov	r3, r7
 1072 0014 0F33     		add	r3, r3, #15
 1073 0016 0022     		mov	r2, #0
 1074 0018 1A70     		strb	r2, [r3]
 578:../Generated_Code/LCD1.c **** 
 579:../Generated_Code/LCD1.c ****   if (increment) {
 1075              		.loc 1 579 0
 1076 001a FB1D     		add	r3, r7, #7
 1077 001c 1B78     		ldrb	r3, [r3]
 1078 001e 002B     		cmp	r3, #0
 1079 0020 07D0     		beq	.L47
 580:../Generated_Code/LCD1.c ****     flags |= EntryModeSet_IncrementOn;
 1080              		.loc 1 580 0
 1081 0022 3B1C     		mov	r3, r7
 1082 0024 0F33     		add	r3, r3, #15
 1083 0026 3A1C     		mov	r2, r7
 1084 0028 0F32     		add	r2, r2, #15
 1085 002a 1278     		ldrb	r2, [r2]
 1086 002c 0221     		mov	r1, #2
 1087 002e 0A43     		orr	r2, r1
 1088 0030 1A70     		strb	r2, [r3]
 1089              	.L47:
 581:../Generated_Code/LCD1.c ****   }
 582:../Generated_Code/LCD1.c ****   if (shiftLeft) {
 1090              		.loc 1 582 0
 1091 0032 BB1D     		add	r3, r7, #6
 1092 0034 1B78     		ldrb	r3, [r3]
 1093 0036 002B     		cmp	r3, #0
 1094 0038 07D0     		beq	.L48
 583:../Generated_Code/LCD1.c ****     flags |= EntryModeSet_ShiftOn;
 1095              		.loc 1 583 0
 1096 003a 3B1C     		mov	r3, r7
 1097 003c 0F33     		add	r3, r3, #15
 1098 003e 3A1C     		mov	r2, r7
 1099 0040 0F32     		add	r2, r2, #15
 1100 0042 1278     		ldrb	r2, [r2]
 1101 0044 0121     		mov	r1, #1
 1102 0046 0A43     		orr	r2, r1
 1103 0048 1A70     		strb	r2, [r3]
 1104              	.L48:
 584:../Generated_Code/LCD1.c ****   }
 585:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand((byte)(EntryModeSetCmd|flags)); /* Entry mode set: Increment mode, display s
 1105              		.loc 1 585 0
 1106 004a 3B1C     		mov	r3, r7
 1107 004c 0F33     		add	r3, r3, #15
 1108 004e 1B78     		ldrb	r3, [r3]
 1109 0050 0422     		mov	r2, #4
 1110 0052 1343     		orr	r3, r2
 1111 0054 DBB2     		uxtb	r3, r3
 1112 0056 181C     		mov	r0, r3
 1113 0058 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 586:../Generated_Code/LCD1.c **** }
 1114              		.loc 1 586 0
 1115 005c BD46     		mov	sp, r7
 1116 005e 04B0     		add	sp, sp, #16
 1117              		@ sp needed for prologue
 1118 0060 80BD     		pop	{r7, pc}
 1119              		.cfi_endproc
 1120              	.LFE16:
 1122 0062 C046     		.section	.text.LCD1_UseDisplay,"ax",%progbits
 1123              		.align	2
 1124              		.global	LCD1_UseDisplay
 1125              		.code	16
 1126              		.thumb_func
 1128              	LCD1_UseDisplay:
 1129              	.LFB17:
 587:../Generated_Code/LCD1.c **** 
 588:../Generated_Code/LCD1.c **** /*
 589:../Generated_Code/LCD1.c **** ** ===================================================================
 590:../Generated_Code/LCD1.c **** **     Method      :  LCD1_UseDisplay (component LCDHTA)
 591:../Generated_Code/LCD1.c **** **     Description :
 592:../Generated_Code/LCD1.c **** **         
 593:../Generated_Code/LCD1.c **** **     Parameters  :
 594:../Generated_Code/LCD1.c **** **         NAME            - DESCRIPTION
 595:../Generated_Code/LCD1.c **** **         display         - Has to be either 1 (top display,
 596:../Generated_Code/LCD1.c **** **                           using E1) or 2 (bottom display, using E2)
 597:../Generated_Code/LCD1.c **** **     Returns     :
 598:../Generated_Code/LCD1.c **** **         ---             - Error code
 599:../Generated_Code/LCD1.c **** ** ===================================================================
 600:../Generated_Code/LCD1.c **** */
 601:../Generated_Code/LCD1.c **** byte LCD1_UseDisplay(byte display)
 602:../Generated_Code/LCD1.c **** {
 1130              		.loc 1 602 0
 1131              		.cfi_startproc
 1132 0000 80B5     		push	{r7, lr}
 1133              	.LCFI44:
 1134              		.cfi_def_cfa_offset 8
 1135              		.cfi_offset 7, -8
 1136              		.cfi_offset 14, -4
 1137 0002 82B0     		sub	sp, sp, #8
 1138              	.LCFI45:
 1139              		.cfi_def_cfa_offset 16
 1140 0004 00AF     		add	r7, sp, #0
 1141              	.LCFI46:
 1142              		.cfi_def_cfa_register 7
 1143 0006 021C     		mov	r2, r0
 1144 0008 FB1D     		add	r3, r7, #7
 1145 000a 1A70     		strb	r2, [r3]
 603:../Generated_Code/LCD1.c ****   (void)display; /* not used, as not using E2 (additional enable) signal */
 604:../Generated_Code/LCD1.c ****   return ERR_OK;
 1146              		.loc 1 604 0
 1147 000c 0023     		mov	r3, #0
 605:../Generated_Code/LCD1.c **** }
 1148              		.loc 1 605 0
 1149 000e 181C     		mov	r0, r3
 1150 0010 BD46     		mov	sp, r7
 1151 0012 02B0     		add	sp, sp, #8
 1152              		@ sp needed for prologue
 1153 0014 80BD     		pop	{r7, pc}
 1154              		.cfi_endproc
 1155              	.LFE17:
 1157 0016 C046     		.section	.text.LCD1_CursorShiftRight,"ax",%progbits
 1158              		.align	2
 1159              		.global	LCD1_CursorShiftRight
 1160              		.code	16
 1161              		.thumb_func
 1163              	LCD1_CursorShiftRight:
 1164              	.LFB18:
 606:../Generated_Code/LCD1.c **** 
 607:../Generated_Code/LCD1.c **** /*
 608:../Generated_Code/LCD1.c **** ** ===================================================================
 609:../Generated_Code/LCD1.c **** **     Method      :  LCD1_CursorShiftRight (component LCDHTA)
 610:../Generated_Code/LCD1.c **** **     Description :
 611:../Generated_Code/LCD1.c **** **         Shift the cursor to the right.
 612:../Generated_Code/LCD1.c **** **     Parameters  : None
 613:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 614:../Generated_Code/LCD1.c **** ** ===================================================================
 615:../Generated_Code/LCD1.c **** */
 616:../Generated_Code/LCD1.c **** void LCD1_CursorShiftRight(void)
 617:../Generated_Code/LCD1.c **** {
 1165              		.loc 1 617 0
 1166              		.cfi_startproc
 1167 0000 80B5     		push	{r7, lr}
 1168              	.LCFI47:
 1169              		.cfi_def_cfa_offset 8
 1170              		.cfi_offset 7, -8
 1171              		.cfi_offset 14, -4
 1172 0002 00AF     		add	r7, sp, #0
 1173              	.LCFI48:
 1174              		.cfi_def_cfa_register 7
 618:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(RightShiftCursor);
 1175              		.loc 1 618 0
 1176 0004 1420     		mov	r0, #20
 1177 0006 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 619:../Generated_Code/LCD1.c **** }
 1178              		.loc 1 619 0
 1179 000a BD46     		mov	sp, r7
 1180              		@ sp needed for prologue
 1181 000c 80BD     		pop	{r7, pc}
 1182              		.cfi_endproc
 1183              	.LFE18:
 1185 000e C046     		.section	.text.LCD1_CursorShiftLeft,"ax",%progbits
 1186              		.align	2
 1187              		.global	LCD1_CursorShiftLeft
 1188              		.code	16
 1189              		.thumb_func
 1191              	LCD1_CursorShiftLeft:
 1192              	.LFB19:
 620:../Generated_Code/LCD1.c **** 
 621:../Generated_Code/LCD1.c **** /*
 622:../Generated_Code/LCD1.c **** ** ===================================================================
 623:../Generated_Code/LCD1.c **** **     Method      :  LCD1_CursorShiftLeft (component LCDHTA)
 624:../Generated_Code/LCD1.c **** **     Description :
 625:../Generated_Code/LCD1.c **** **         Shift the cursor to the left.
 626:../Generated_Code/LCD1.c **** **     Parameters  : None
 627:../Generated_Code/LCD1.c **** **     Returns     : Nothing
 628:../Generated_Code/LCD1.c **** ** ===================================================================
 629:../Generated_Code/LCD1.c **** */
 630:../Generated_Code/LCD1.c **** void LCD1_CursorShiftLeft(void)
 631:../Generated_Code/LCD1.c **** {
 1193              		.loc 1 631 0
 1194              		.cfi_startproc
 1195 0000 80B5     		push	{r7, lr}
 1196              	.LCFI49:
 1197              		.cfi_def_cfa_offset 8
 1198              		.cfi_offset 7, -8
 1199              		.cfi_offset 14, -4
 1200 0002 00AF     		add	r7, sp, #0
 1201              	.LCFI50:
 1202              		.cfi_def_cfa_register 7
 632:../Generated_Code/LCD1.c ****   LCD1_WriteLCDCommand(LeftShiftCursor);
 1203              		.loc 1 632 0
 1204 0004 1020     		mov	r0, #16
 1205 0006 FFF7FEFF 		bl	LCD1_WriteLCDCommand
 633:../Generated_Code/LCD1.c **** }
 1206              		.loc 1 633 0
 1207 000a BD46     		mov	sp, r7
 1208              		@ sp needed for prologue
 1209 000c 80BD     		pop	{r7, pc}
 1210              		.cfi_endproc
 1211              	.LFE19:
 1213 000e C046     		.text
 1214              	.Letext0:
 1215              		.file 2 "C:/Freescale/CW MCU v10.7/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1216              		.file 3 "../Generated_Code/PE_Types.h"
DEFINED SYMBOLS
                            *ABS*:00000000 LCD1.c
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:22     .rodata.LCD1_SoftCharUE:00000000 LCD1_SoftCharUE
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:19     .rodata.LCD1_SoftCharUE:00000000 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:36     .rodata.LCD1_SoftCharAE:00000000 LCD1_SoftCharAE
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:33     .rodata.LCD1_SoftCharAE:00000000 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:50     .rodata.LCD1_SoftCharOE:00000000 LCD1_SoftCharOE
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:47     .rodata.LCD1_SoftCharOE:00000000 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:60     .text.DataGet:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:64     .text.DataGet:00000000 DataGet
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:138    .text.DataGet:00000068 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:143    .text.DataPut:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:147    .text.DataPut:00000000 DataPut
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:225    .text.DataPut:0000007c $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:230    .text.EnablePulse:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:234    .text.EnablePulse:00000000 EnablePulse
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:265    .text.EnablePulse:00000020 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:270    .text.LCD1_WaitForLCDReady:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:275    .text.LCD1_WaitForLCDReady:00000000 LCD1_WaitForLCDReady
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:404    .text.LCD1_WaitForLCDReady:000000e0 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:409    .text.LCD1_WriteLCDCommand:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:414    .text.LCD1_WriteLCDCommand:00000000 LCD1_WriteLCDCommand
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:472    .text.LCD1_Clear:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:477    .text.LCD1_Clear:00000000 LCD1_Clear
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:500    .text.LCD1_Home:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:505    .text.LCD1_Home:00000000 LCD1_Home
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:528    .text.LCD1_WriteLCDData:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:533    .text.LCD1_WriteLCDData:00000000 LCD1_WriteLCDData
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:600    .text.LCD1_WriteLCDData:00000064 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:605    .text.LCD1_GotoXY:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:610    .text.LCD1_GotoXY:00000000 LCD1_GotoXY
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:661    .text.LCD1_ShiftLeft:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:666    .text.LCD1_ShiftLeft:00000000 LCD1_ShiftLeft
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:689    .text.LCD1_WriteLn:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:694    .text.LCD1_WriteLn:00000000 LCD1_WriteLn
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:717    .text.LCD1_WriteString:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:722    .text.LCD1_WriteString:00000000 LCD1_WriteString
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:765    .text.LCD1_WriteLineStr:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:770    .text.LCD1_WriteLineStr:00000000 LCD1_WriteLineStr
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:863    .text.LCD1_Line:00000000 LCD1_Line
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:858    .text.LCD1_Line:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:905    .text.LCD1_Init:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:910    .text.LCD1_Init:00000000 LCD1_Init
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1011   .text.LCD1_Init:000000b4 $d
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1016   .text.LCD1_ShiftRight:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1021   .text.LCD1_ShiftRight:00000000 LCD1_ShiftRight
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1044   .text.LCD1_SetEntryMode:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1049   .text.LCD1_SetEntryMode:00000000 LCD1_SetEntryMode
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1123   .text.LCD1_UseDisplay:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1128   .text.LCD1_UseDisplay:00000000 LCD1_UseDisplay
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1158   .text.LCD1_CursorShiftRight:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1163   .text.LCD1_CursorShiftRight:00000000 LCD1_CursorShiftRight
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1186   .text.LCD1_CursorShiftLeft:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccXFIowL.s:1191   .text.LCD1_CursorShiftLeft:00000000 LCD1_CursorShiftLeft
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
BitIoLdd13_GetVal
BitIoLdd12_GetVal
BitIoLdd11_GetVal
BitIoLdd10_GetVal
PE_LDD_DeviceDataList
BitIoLdd13_PutVal
BitIoLdd12_PutVal
BitIoLdd11_PutVal
BitIoLdd10_PutVal
BitIoLdd4_SetVal
WAIT1_Wait10Cycles
BitIoLdd4_ClrVal
BitIoLdd10_SetInput
BitIoLdd11_SetInput
BitIoLdd12_SetInput
BitIoLdd13_SetInput
BitIoLdd15_SetVal
BitIoLdd15_ClrVal
BitIoLdd10_SetOutput
BitIoLdd11_SetOutput
BitIoLdd12_SetOutput
BitIoLdd13_SetOutput
WAIT1_WaitCycles
BitIoLdd5_SetVal
BitIoLdd5_ClrVal
WAIT1_Waitms
