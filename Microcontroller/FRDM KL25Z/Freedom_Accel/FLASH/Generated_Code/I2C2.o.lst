   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2C2.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	24
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	INT_I2C0__DEFAULT_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.I2C2_Interrupt,"ax",%progbits
  30              		.align	2
  31              		.global	I2C2_Interrupt
  32              		.code	16
  33              		.thumb_func
  35              	I2C2_Interrupt:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/I2C2.c"
   1:../Generated_Code/I2C2.c **** /* ###################################################################
   2:../Generated_Code/I2C2.c **** **     This component module is generated by Processor Expert. Do not modify it.
   3:../Generated_Code/I2C2.c **** **     Filename    : I2C2.c
   4:../Generated_Code/I2C2.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/I2C2.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/I2C2.c **** **     Component   : I2C_LDD
   7:../Generated_Code/I2C2.c **** **     Version     : Component 01.016, Driver 01.07, CPU db: 3.00.000
   8:../Generated_Code/I2C2.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/I2C2.c **** **     Date/Time   : 2017-11-04, 02:10, # CodeGen: 0
  10:../Generated_Code/I2C2.c **** **     Abstract    :
  11:../Generated_Code/I2C2.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/I2C2.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/I2C2.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/I2C2.c **** **          Interface features:
  15:../Generated_Code/I2C2.c **** **          MASTER mode
  16:../Generated_Code/I2C2.c **** **            - Multi master communication
  17:../Generated_Code/I2C2.c **** **            - The combined format of communication possible
  18:../Generated_Code/I2C2.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/I2C2.c **** **            - Acknowledge polling provided
  21:../Generated_Code/I2C2.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/I2C2.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/I2C2.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/I2C2.c **** **          SLAVE mode
  25:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing
  26:../Generated_Code/I2C2.c **** **            - General call address detection provided
  27:../Generated_Code/I2C2.c **** **     Settings    :
  28:../Generated_Code/I2C2.c **** **          Component name                                 : I2C2
  29:../Generated_Code/I2C2.c **** **          I2C channel                                    : I2C0
  30:../Generated_Code/I2C2.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/I2C2.c **** **            Interrupt                                    : INT_I2C0
  32:../Generated_Code/I2C2.c **** **            Interrupt priority                           : medium priority
  33:../Generated_Code/I2C2.c **** **          Settings                                       : 
  34:../Generated_Code/I2C2.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/I2C2.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/I2C2.c **** **              Initialization                             : 
  37:../Generated_Code/I2C2.c **** **                Address mode                             : 7-bit addressing
  38:../Generated_Code/I2C2.c **** **                Target slave address init                : 1D
  39:../Generated_Code/I2C2.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/I2C2.c **** **            Pins                                         : 
  41:../Generated_Code/I2C2.c **** **              SDA pin                                    : 
  42:../Generated_Code/I2C2.c **** **                SDA pin                                  : PTE25/TPM0_CH1/I2C0_SDA
  43:../Generated_Code/I2C2.c **** **                SDA pin signal                           : I2C_SDA
  44:../Generated_Code/I2C2.c **** **              SCL pin                                    : 
  45:../Generated_Code/I2C2.c **** **                SCL pin                                  : PTE24/TPM0_CH0/I2C0_SCL
  46:../Generated_Code/I2C2.c **** **                SCL pin signal                           : I2C_SCL
  47:../Generated_Code/I2C2.c **** **              High drive select                          : Disabled
  48:../Generated_Code/I2C2.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/I2C2.c **** **            Internal frequency (multiplier factor)       : 20.97152 MHz
  50:../Generated_Code/I2C2.c **** **            Bits 0-2 of Frequency divider register       : 000
  51:../Generated_Code/I2C2.c **** **            Bits 3-5 of Frequency divider register       : 000
  52:../Generated_Code/I2C2.c **** **            SCL frequency                                : 1048.576 kHz
  53:../Generated_Code/I2C2.c **** **            SDA Hold                                     : 0.334 us
  54:../Generated_Code/I2C2.c **** **            SCL start Hold                               : 0.286 us
  55:../Generated_Code/I2C2.c **** **            SCL stop Hold                                : 0.525 us
  56:../Generated_Code/I2C2.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/I2C2.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/I2C2.c **** **          Initialization                                 : 
  59:../Generated_Code/I2C2.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/I2C2.c **** **            Auto initialization                          : no
  61:../Generated_Code/I2C2.c **** **            Event mask                                   : 
  62:../Generated_Code/I2C2.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/I2C2.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/I2C2.c **** **              OnMasterByteReceived                       : Disabled
  65:../Generated_Code/I2C2.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/I2C2.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/I2C2.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/I2C2.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/I2C2.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/I2C2.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/I2C2.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/I2C2.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/I2C2.c **** **              OnError                                    : Enabled
  74:../Generated_Code/I2C2.c **** **              OnBusStopDetected                          : Disabled
  75:../Generated_Code/I2C2.c **** **          CPU clock/configuration selection              : 
  76:../Generated_Code/I2C2.c **** **            Clock configuration 0                        : This component enabled
  77:../Generated_Code/I2C2.c **** **            Clock configuration 1                        : This component disabled
  78:../Generated_Code/I2C2.c **** **            Clock configuration 2                        : This component disabled
  79:../Generated_Code/I2C2.c **** **            Clock configuration 3                        : This component disabled
  80:../Generated_Code/I2C2.c **** **            Clock configuration 4                        : This component disabled
  81:../Generated_Code/I2C2.c **** **            Clock configuration 5                        : This component disabled
  82:../Generated_Code/I2C2.c **** **            Clock configuration 6                        : This component disabled
  83:../Generated_Code/I2C2.c **** **            Clock configuration 7                        : This component disabled
  84:../Generated_Code/I2C2.c **** **     Contents    :
  85:../Generated_Code/I2C2.c **** **         Init               - LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr);
  86:../Generated_Code/I2C2.c **** **         Deinit             - void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr);
  87:../Generated_Code/I2C2.c **** **         MasterSendBlock    - LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD
  88:../Generated_Code/I2C2.c **** **         MasterReceiveBlock - LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, 
  89:../Generated_Code/I2C2.c **** **         SelectSlaveDevice  - LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr,..
  90:../Generated_Code/I2C2.c **** **         GetError           - LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TE
  91:../Generated_Code/I2C2.c **** **
  92:../Generated_Code/I2C2.c **** **     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
  93:../Generated_Code/I2C2.c **** **     All Rights Reserved.
  94:../Generated_Code/I2C2.c **** **     
  95:../Generated_Code/I2C2.c **** **     Redistribution and use in source and binary forms, with or without modification,
  96:../Generated_Code/I2C2.c **** **     are permitted provided that the following conditions are met:
  97:../Generated_Code/I2C2.c **** **     
  98:../Generated_Code/I2C2.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  99:../Generated_Code/I2C2.c **** **       of conditions and the following disclaimer.
 100:../Generated_Code/I2C2.c **** **     
 101:../Generated_Code/I2C2.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
 102:../Generated_Code/I2C2.c **** **       list of conditions and the following disclaimer in the documentation and/or
 103:../Generated_Code/I2C2.c **** **       other materials provided with the distribution.
 104:../Generated_Code/I2C2.c **** **     
 105:../Generated_Code/I2C2.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
 106:../Generated_Code/I2C2.c **** **       contributors may be used to endorse or promote products derived from this
 107:../Generated_Code/I2C2.c **** **       software without specific prior written permission.
 108:../Generated_Code/I2C2.c **** **     
 109:../Generated_Code/I2C2.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 110:../Generated_Code/I2C2.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 111:../Generated_Code/I2C2.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 112:../Generated_Code/I2C2.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 113:../Generated_Code/I2C2.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 114:../Generated_Code/I2C2.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 115:../Generated_Code/I2C2.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 116:../Generated_Code/I2C2.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 117:../Generated_Code/I2C2.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 118:../Generated_Code/I2C2.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 119:../Generated_Code/I2C2.c **** **     
 120:../Generated_Code/I2C2.c **** **     http: www.freescale.com
 121:../Generated_Code/I2C2.c **** **     mail: support@freescale.com
 122:../Generated_Code/I2C2.c **** ** ###################################################################*/
 123:../Generated_Code/I2C2.c **** /*!
 124:../Generated_Code/I2C2.c **** ** @file I2C2.c
 125:../Generated_Code/I2C2.c **** ** @version 01.07
 126:../Generated_Code/I2C2.c **** ** @brief
 127:../Generated_Code/I2C2.c **** **          This component encapsulates the internal I2C communication
 128:../Generated_Code/I2C2.c **** **          interface. The implementation of the interface is based
 129:../Generated_Code/I2C2.c **** **          on the Philips I2C-bus specification version 2.0.
 130:../Generated_Code/I2C2.c **** **          Interface features:
 131:../Generated_Code/I2C2.c **** **          MASTER mode
 132:../Generated_Code/I2C2.c **** **            - Multi master communication
 133:../Generated_Code/I2C2.c **** **            - The combined format of communication possible
 134:../Generated_Code/I2C2.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
 135:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
 136:../Generated_Code/I2C2.c **** **            - Acknowledge polling provided
 137:../Generated_Code/I2C2.c **** **            - No wait state initiated when a slave device holds the SCL line low
 138:../Generated_Code/I2C2.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
 139:../Generated_Code/I2C2.c **** **            - Invalid start/stop condition detection provided
 140:../Generated_Code/I2C2.c **** **          SLAVE mode
 141:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing
 142:../Generated_Code/I2C2.c **** **            - General call address detection provided
 143:../Generated_Code/I2C2.c **** */         
 144:../Generated_Code/I2C2.c **** /*!
 145:../Generated_Code/I2C2.c **** **  @addtogroup I2C2_module I2C2 module documentation
 146:../Generated_Code/I2C2.c **** **  @{
 147:../Generated_Code/I2C2.c **** */         
 148:../Generated_Code/I2C2.c **** 
 149:../Generated_Code/I2C2.c **** /* MODULE I2C2. */
 150:../Generated_Code/I2C2.c **** 
 151:../Generated_Code/I2C2.c **** #include "Events.h"
 152:../Generated_Code/I2C2.c **** #include "I2C2.h"
 153:../Generated_Code/I2C2.c **** #include "PORT_PDD.h"
 154:../Generated_Code/I2C2.c **** #include "I2C_PDD.h"
 155:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} No RTOS includes */
 156:../Generated_Code/I2C2.c **** #include "IO_Map.h"
 157:../Generated_Code/I2C2.c **** 
 158:../Generated_Code/I2C2.c **** #ifdef __cplusplus
 159:../Generated_Code/I2C2.c **** extern "C" {
 160:../Generated_Code/I2C2.c **** #endif 
 161:../Generated_Code/I2C2.c **** 
 162:../Generated_Code/I2C2.c **** 
 163:../Generated_Code/I2C2.c **** /* SerFlag bits */
 164:../Generated_Code/I2C2.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 165:../Generated_Code/I2C2.c **** #define ADDR_COMPLETE           0x02U  /* 10-bit address transmission complete   */
 166:../Generated_Code/I2C2.c **** #define REP_ADDR_COMPLETE       0x04U  /* repeated address transmission complete */
 167:../Generated_Code/I2C2.c **** #define GENERAL_CALL            0x08U  /* General call flag */
 168:../Generated_Code/I2C2.c **** #define ADDR_10                 0x10U  /* 10-bit addr flag */
 169:../Generated_Code/I2C2.c **** #define ADDR_7                  0x20U  /* 7-bit addr flag */
 170:../Generated_Code/I2C2.c **** 
 171:../Generated_Code/I2C2.c **** typedef struct {
 172:../Generated_Code/I2C2.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 173:../Generated_Code/I2C2.c ****                                        /* Bits: 0 - Running int from TX */
 174:../Generated_Code/I2C2.c ****                                        /*       1 - 10-bit address transmission complete   */
 175:../Generated_Code/I2C2.c ****                                        /*       2 - repeated address transmission complete */
 176:../Generated_Code/I2C2.c ****                                        /*       3 - General Call flag */
 177:../Generated_Code/I2C2.c ****                                        /*       4 - 10-bit addr flag */
 178:../Generated_Code/I2C2.c ****                                        /*       5 - 7-bit addr flag */
 179:../Generated_Code/I2C2.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 180:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask;        /* Variable for errors mask value */
 181:../Generated_Code/I2C2.c ****   uint8_t SlaveAddr;                   /* Variable for Slave address */
 182:../Generated_Code/I2C2.c ****   uint8_t SlaveAddrHigh;               /* Variable for High byte of the Slave address (10-bit addre
 183:../Generated_Code/I2C2.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 184:../Generated_Code/I2C2.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 185:../Generated_Code/I2C2.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 186:../Generated_Code/I2C2.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 187:../Generated_Code/I2C2.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 188:../Generated_Code/I2C2.c **** } I2C2_TDeviceData;
 189:../Generated_Code/I2C2.c **** 
 190:../Generated_Code/I2C2.c **** typedef I2C2_TDeviceData *I2C2_TDeviceDataPtr; /* Pointer to the device data structure. */
 191:../Generated_Code/I2C2.c **** 
 192:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 193:../Generated_Code/I2C2.c **** static I2C2_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 194:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 195:../Generated_Code/I2C2.c **** static I2C2_TDeviceDataPtr INT_I2C0__DEFAULT_RTOS_ISRPARAM;
 196:../Generated_Code/I2C2.c **** 
 197:../Generated_Code/I2C2.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED | LD
 198:../Generated_Code/I2C2.c **** 
 199:../Generated_Code/I2C2.c **** /*
 200:../Generated_Code/I2C2.c **** ** ===================================================================
 201:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Interrupt (component I2C_LDD)
 202:../Generated_Code/I2C2.c **** **
 203:../Generated_Code/I2C2.c **** **     Description :
 204:../Generated_Code/I2C2.c **** **         The method services the interrupt of the selected peripheral(s)
 205:../Generated_Code/I2C2.c **** **         and eventually invokes event(s) of the component.
 206:../Generated_Code/I2C2.c **** **         This method is internal. It is used by Processor Expert only.
 207:../Generated_Code/I2C2.c **** ** ===================================================================
 208:../Generated_Code/I2C2.c **** */
 209:../Generated_Code/I2C2.c **** 
 210:../Generated_Code/I2C2.c **** PE_ISR(I2C2_Interrupt)
 211:../Generated_Code/I2C2.c **** {
  38              		.loc 1 211 0
  39              		.cfi_startproc
  40 0000 90B5     		push	{r4, r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 12
  43              		.cfi_offset 4, -12
  44              		.cfi_offset 7, -8
  45              		.cfi_offset 14, -4
  46 0002 83B0     		sub	sp, sp, #12
  47              	.LCFI1:
  48              		.cfi_def_cfa_offset 24
  49 0004 00AF     		add	r7, sp, #0
  50              	.LCFI2:
  51              		.cfi_def_cfa_register 7
 212:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 213:../Generated_Code/I2C2.c ****   I2C2_TDeviceDataPtr DeviceDataPrv = INT_I2C0__DEFAULT_RTOS_ISRPARAM;
  52              		.loc 1 213 0
  53 0006 AA4B     		ldr	r3, .L16
  54 0008 1B68     		ldr	r3, [r3]
  55 000a 3B60     		str	r3, [r7]
 214:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask = 0x00U; /* Temporary variable for error mask */
  56              		.loc 1 214 0
  57 000c BB1D     		add	r3, r7, #6
  58 000e 0022     		mov	r2, #0
  59 0010 1A80     		strh	r2, [r3]
 215:../Generated_Code/I2C2.c ****   register uint8_t Status;             /* Temporary variable for status register */
 216:../Generated_Code/I2C2.c **** 
 217:../Generated_Code/I2C2.c ****   Status = I2C_PDD_ReadStatusReg(I2C0_BASE_PTR); /* Safe status register */
  60              		.loc 1 217 0
  61 0012 A84B     		ldr	r3, .L16+4
  62 0014 DB78     		ldrb	r3, [r3, #3]
  63 0016 DCB2     		uxtb	r4, r3
 218:../Generated_Code/I2C2.c ****   I2C_PDD_ClearInterruptFlags(I2C0_BASE_PTR, (Status)); /* Clear interrupt flag */
  64              		.loc 1 218 0
  65 0018 A64B     		ldr	r3, .L16+4
  66 001a A64A     		ldr	r2, .L16+4
  67 001c D278     		ldrb	r2, [r2, #3]
  68 001e D2B2     		uxtb	r2, r2
  69 0020 D2B2     		uxtb	r2, r2
  70 0022 1221     		mov	r1, #18
  71 0024 8A43     		bic	r2, r1
  72 0026 D1B2     		uxtb	r1, r2
  73 0028 E2B2     		uxtb	r2, r4
  74 002a 0A43     		orr	r2, r1
  75 002c D2B2     		uxtb	r2, r2
  76 002e D2B2     		uxtb	r2, r2
  77 0030 DA70     		strb	r2, [r3, #3]
 219:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
  78              		.loc 1 219 0
  79 0032 A04B     		ldr	r3, .L16+4
  80 0034 9B78     		ldrb	r3, [r3, #2]
  81 0036 DBB2     		uxtb	r3, r3
  82 0038 1A1C     		mov	r2, r3
  83 003a 2023     		mov	r3, #32
  84 003c 1340     		and	r3, r2
  85 003e 00D1     		bne	.LCB45
  86 0040 FFE0     		b	.L2	@long jump
  87              	.LCB45:
 220:../Generated_Code/I2C2.c ****     if (I2C_PDD_GetTransmitMode(I2C0_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
  88              		.loc 1 220 0
  89 0042 9C4B     		ldr	r3, .L16+4
  90 0044 9B78     		ldrb	r3, [r3, #2]
  91 0046 DBB2     		uxtb	r3, r3
  92 0048 1A1C     		mov	r2, r3
  93 004a 1023     		mov	r3, #16
  94 004c 1340     		and	r3, r2
  95 004e 00D1     		bne	.LCB53
  96 0050 B6E0     		b	.L3	@long jump
  97              	.LCB53:
 221:../Generated_Code/I2C2.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
  98              		.loc 1 221 0
  99 0052 221C     		mov	r2, r4
 100 0054 0123     		mov	r3, #1
 101 0056 1340     		and	r3, r2
 102 0058 2AD0     		beq	.L4
 222:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
 103              		.loc 1 222 0
 104 005a 964B     		ldr	r3, .L16+4
 105 005c 954A     		ldr	r2, .L16+4
 106 005e 9278     		ldrb	r2, [r2, #2]
 107 0060 D2B2     		uxtb	r2, r2
 108 0062 2021     		mov	r1, #32
 109 0064 8A43     		bic	r2, r1
 110 0066 D2B2     		uxtb	r2, r2
 111 0068 9A70     		strb	r2, [r3, #2]
 223:../Generated_Code/I2C2.c ****         I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 112              		.loc 1 223 0
 113 006a 924B     		ldr	r3, .L16+4
 114 006c 914A     		ldr	r2, .L16+4
 115 006e 9278     		ldrb	r2, [r2, #2]
 116 0070 D2B2     		uxtb	r2, r2
 117 0072 1021     		mov	r1, #16
 118 0074 8A43     		bic	r2, r1
 119 0076 D2B2     		uxtb	r2, r2
 120 0078 9A70     		strb	r2, [r3, #2]
 224:../Generated_Code/I2C2.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 121              		.loc 1 224 0
 122 007a 3B68     		ldr	r3, [r7]
 123 007c 0022     		mov	r2, #0
 124 007e 9A81     		strh	r2, [r3, #12]
 225:../Generated_Code/I2C2.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 125              		.loc 1 225 0
 126 0080 3B68     		ldr	r3, [r7]
 127 0082 0022     		mov	r2, #0
 128 0084 DA80     		strh	r2, [r3, #6]
 226:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 129              		.loc 1 226 0
 130 0086 3B68     		ldr	r3, [r7]
 131 0088 1B78     		ldrb	r3, [r3]
 132 008a 0122     		mov	r2, #1
 133 008c 9343     		bic	r3, r2
 134 008e DAB2     		uxtb	r2, r3
 135 0090 3B68     		ldr	r3, [r7]
 136 0092 1A70     		strb	r2, [r3]
 227:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Set the flag */
 137              		.loc 1 227 0
 138 0094 3B68     		ldr	r3, [r7]
 139 0096 1B78     		ldrb	r3, [r3]
 140 0098 0622     		mov	r2, #6
 141 009a 1343     		orr	r3, r2
 142 009c DAB2     		uxtb	r2, r3
 143 009e 3B68     		ldr	r3, [r7]
 144 00a0 1A70     		strb	r2, [r3]
 228:../Generated_Code/I2C2.c ****         ErrorMask |= LDD_I2C_MASTER_NACK; /* Set the Master Nack error mask */
 145              		.loc 1 228 0
 146 00a2 BB1D     		add	r3, r7, #6
 147 00a4 BA1D     		add	r2, r7, #6
 148 00a6 1288     		ldrh	r2, [r2]
 149 00a8 0821     		mov	r1, #8
 150 00aa 0A43     		orr	r2, r1
 151 00ac 1A80     		strh	r2, [r3]
 152 00ae EAE0     		b	.L5
 153              	.L4:
 229:../Generated_Code/I2C2.c ****       } else {
 230:../Generated_Code/I2C2.c ****         if ((DeviceDataPrv->SerFlag & ADDR_COMPLETE) != 0x00U) { /* If 10-bit addr has been complet
 154              		.loc 1 230 0
 155 00b0 3B68     		ldr	r3, [r7]
 156 00b2 1B78     		ldrb	r3, [r3]
 157 00b4 1A1C     		mov	r2, r3
 158 00b6 0223     		mov	r3, #2
 159 00b8 1340     		and	r3, r2
 160 00ba 00D1     		bne	.LCB111
 161 00bc 74E0     		b	.L6	@long jump
 162              	.LCB111:
 231:../Generated_Code/I2C2.c ****           if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 163              		.loc 1 231 0
 164 00be 3B68     		ldr	r3, [r7]
 165 00c0 9B89     		ldrh	r3, [r3, #12]
 166 00c2 002B     		cmp	r3, #0
 167 00c4 0ED0     		beq	.L7
 232:../Generated_Code/I2C2.c ****             DeviceDataPrv->OutLenM--;  /* Decrease number of chars for the transmit */
 168              		.loc 1 232 0
 169 00c6 3B68     		ldr	r3, [r7]
 170 00c8 9B89     		ldrh	r3, [r3, #12]
 171 00ca 013B     		sub	r3, r3, #1
 172 00cc 9AB2     		uxth	r2, r3
 173 00ce 3B68     		ldr	r3, [r7]
 174 00d0 9A81     		strh	r2, [r3, #12]
 233:../Generated_Code/I2C2.c ****             I2C_PDD_WriteDataReg(I2C0_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 175              		.loc 1 233 0
 176 00d2 784A     		ldr	r2, .L16+4
 177 00d4 3B68     		ldr	r3, [r7]
 178 00d6 1B69     		ldr	r3, [r3, #16]
 179 00d8 1978     		ldrb	r1, [r3]
 180 00da 1171     		strb	r1, [r2, #4]
 181 00dc 5A1C     		add	r2, r3, #1
 182 00de 3B68     		ldr	r3, [r7]
 183 00e0 1A61     		str	r2, [r3, #16]
 184 00e2 D0E0     		b	.L5
 185              	.L7:
 234:../Generated_Code/I2C2.c ****           } else {
 235:../Generated_Code/I2C2.c ****             if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 186              		.loc 1 235 0
 187 00e4 3B68     		ldr	r3, [r7]
 188 00e6 DB88     		ldrh	r3, [r3, #6]
 189 00e8 002B     		cmp	r3, #0
 190 00ea 3CD0     		beq	.L8
 236:../Generated_Code/I2C2.c ****               if ((DeviceDataPrv->SerFlag & REP_ADDR_COMPLETE) != 0x00U) { /* If repeated start and
 191              		.loc 1 236 0
 192 00ec 3B68     		ldr	r3, [r7]
 193 00ee 1B78     		ldrb	r3, [r3]
 194 00f0 1A1C     		mov	r2, r3
 195 00f2 0423     		mov	r3, #4
 196 00f4 1340     		and	r3, r2
 197 00f6 1FD0     		beq	.L9
 237:../Generated_Code/I2C2.c ****                 if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 198              		.loc 1 237 0
 199 00f8 3B68     		ldr	r3, [r7]
 200 00fa DB88     		ldrh	r3, [r3, #6]
 201 00fc 012B     		cmp	r3, #1
 202 00fe 08D1     		bne	.L10
 238:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* then transmit A
 203              		.loc 1 238 0
 204 0100 6C4B     		ldr	r3, .L16+4
 205 0102 6C4A     		ldr	r2, .L16+4
 206 0104 9278     		ldrb	r2, [r2, #2]
 207 0106 D2B2     		uxtb	r2, r2
 208 0108 0821     		mov	r1, #8
 209 010a 0A43     		orr	r2, r1
 210 010c D2B2     		uxtb	r2, r2
 211 010e 9A70     		strb	r2, [r3, #2]
 212 0110 07E0     		b	.L11
 213              	.L10:
 239:../Generated_Code/I2C2.c ****                 } else {
 240:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* else transmit AC
 214              		.loc 1 240 0
 215 0112 684B     		ldr	r3, .L16+4
 216 0114 674A     		ldr	r2, .L16+4
 217 0116 9278     		ldrb	r2, [r2, #2]
 218 0118 D2B2     		uxtb	r2, r2
 219 011a 0821     		mov	r1, #8
 220 011c 8A43     		bic	r2, r1
 221 011e D2B2     		uxtb	r2, r2
 222 0120 9A70     		strb	r2, [r3, #2]
 223              	.L11:
 241:../Generated_Code/I2C2.c ****                 }
 242:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 224              		.loc 1 242 0
 225 0122 644B     		ldr	r3, .L16+4
 226 0124 634A     		ldr	r2, .L16+4
 227 0126 9278     		ldrb	r2, [r2, #2]
 228 0128 D2B2     		uxtb	r2, r2
 229 012a 1021     		mov	r1, #16
 230 012c 8A43     		bic	r2, r1
 231 012e D2B2     		uxtb	r2, r2
 232 0130 9A70     		strb	r2, [r3, #2]
 243:../Generated_Code/I2C2.c ****                 (void)I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Dummy read character */
 233              		.loc 1 243 0
 234 0132 604B     		ldr	r3, .L16+4
 235 0134 1B79     		ldrb	r3, [r3, #4]
 236 0136 A6E0     		b	.L5
 237              	.L9:
 244:../Generated_Code/I2C2.c ****               } else {                 /* Repeated address has not been completed for 10-bit addres
 245:../Generated_Code/I2C2.c ****                 I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* Repeat start cycle generated */
 238              		.loc 1 245 0
 239 0138 5E4B     		ldr	r3, .L16+4
 240 013a 5E4A     		ldr	r2, .L16+4
 241 013c 9278     		ldrb	r2, [r2, #2]
 242 013e D2B2     		uxtb	r2, r2
 243 0140 0421     		mov	r1, #4
 244 0142 0A43     		orr	r2, r1
 245 0144 D2B2     		uxtb	r2, r2
 246 0146 9A70     		strb	r2, [r3, #2]
 246:../Generated_Code/I2C2.c ****                 I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddrHigh | 0x01U)
 247              		.loc 1 246 0
 248 0148 5A4B     		ldr	r3, .L16+4
 249 014a 3A68     		ldr	r2, [r7]
 250 014c 5279     		ldrb	r2, [r2, #5]
 251 014e 0121     		mov	r1, #1
 252 0150 0A43     		orr	r2, r1
 253 0152 D2B2     		uxtb	r2, r2
 254 0154 1A71     		strb	r2, [r3, #4]
 247:../Generated_Code/I2C2.c ****                 DeviceDataPrv->SerFlag |= REP_ADDR_COMPLETE;
 255              		.loc 1 247 0
 256 0156 3B68     		ldr	r3, [r7]
 257 0158 1B78     		ldrb	r3, [r3]
 258 015a 0422     		mov	r2, #4
 259 015c 1343     		orr	r3, r2
 260 015e DAB2     		uxtb	r2, r3
 261 0160 3B68     		ldr	r3, [r7]
 262 0162 1A70     		strb	r2, [r3]
 263 0164 8FE0     		b	.L5
 264              	.L8:
 248:../Generated_Code/I2C2.c ****               }
 249:../Generated_Code/I2C2.c ****             } else {
 250:../Generated_Code/I2C2.c ****               DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 265              		.loc 1 250 0
 266 0166 3B68     		ldr	r3, [r7]
 267 0168 1B78     		ldrb	r3, [r3]
 268 016a 0122     		mov	r2, #1
 269 016c 9343     		bic	r3, r2
 270 016e DAB2     		uxtb	r2, r3
 271 0170 3B68     		ldr	r3, [r7]
 272 0172 1A70     		strb	r2, [r3]
 251:../Generated_Code/I2C2.c ****               if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 273              		.loc 1 251 0
 274 0174 3B68     		ldr	r3, [r7]
 275 0176 5B78     		ldrb	r3, [r3, #1]
 276 0178 012B     		cmp	r3, #1
 277 017a 0FD1     		bne	.L12
 252:../Generated_Code/I2C2.c ****                 I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave
 278              		.loc 1 252 0
 279 017c 4D4B     		ldr	r3, .L16+4
 280 017e 4D4A     		ldr	r2, .L16+4
 281 0180 9278     		ldrb	r2, [r2, #2]
 282 0182 D2B2     		uxtb	r2, r2
 283 0184 2021     		mov	r1, #32
 284 0186 8A43     		bic	r2, r1
 285 0188 D2B2     		uxtb	r2, r2
 286 018a 9A70     		strb	r2, [r3, #2]
 253:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 287              		.loc 1 253 0
 288 018c 494B     		ldr	r3, .L16+4
 289 018e 494A     		ldr	r2, .L16+4
 290 0190 9278     		ldrb	r2, [r2, #2]
 291 0192 D2B2     		uxtb	r2, r2
 292 0194 1021     		mov	r1, #16
 293 0196 8A43     		bic	r2, r1
 294 0198 D2B2     		uxtb	r2, r2
 295 019a 9A70     		strb	r2, [r3, #2]
 296              	.L12:
 254:../Generated_Code/I2C2.c ****               }
 255:../Generated_Code/I2C2.c ****               I2C2_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event */
 297              		.loc 1 255 0
 298 019c 3B68     		ldr	r3, [r7]
 299 019e 5B69     		ldr	r3, [r3, #20]
 300 01a0 181C     		mov	r0, r3
 301 01a2 FFF7FEFF 		bl	I2C2_OnMasterBlockSent
 302 01a6 6EE0     		b	.L5
 303              	.L6:
 256:../Generated_Code/I2C2.c ****             }
 257:../Generated_Code/I2C2.c ****           }
 258:../Generated_Code/I2C2.c ****         } else {
 259:../Generated_Code/I2C2.c ****           I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send second part of the
 304              		.loc 1 259 0
 305 01a8 424B     		ldr	r3, .L16+4
 306 01aa 3A68     		ldr	r2, [r7]
 307 01ac 1279     		ldrb	r2, [r2, #4]
 308 01ae 1A71     		strb	r2, [r3, #4]
 260:../Generated_Code/I2C2.c ****           DeviceDataPrv->SerFlag |= (ADDR_COMPLETE); /* Address complete */
 309              		.loc 1 260 0
 310 01b0 3B68     		ldr	r3, [r7]
 311 01b2 1B78     		ldrb	r3, [r3]
 312 01b4 0222     		mov	r2, #2
 313 01b6 1343     		orr	r3, r2
 314 01b8 DAB2     		uxtb	r2, r3
 315 01ba 3B68     		ldr	r3, [r7]
 316 01bc 1A70     		strb	r2, [r3]
 317 01be 62E0     		b	.L5
 318              	.L3:
 261:../Generated_Code/I2C2.c ****         }
 262:../Generated_Code/I2C2.c ****       }
 263:../Generated_Code/I2C2.c ****     } else {
 264:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 319              		.loc 1 264 0
 320 01c0 3B68     		ldr	r3, [r7]
 321 01c2 DB88     		ldrh	r3, [r3, #6]
 322 01c4 013B     		sub	r3, r3, #1
 323 01c6 9AB2     		uxth	r2, r3
 324 01c8 3B68     		ldr	r3, [r7]
 325 01ca DA80     		strh	r2, [r3, #6]
 265:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 326              		.loc 1 265 0
 327 01cc 3B68     		ldr	r3, [r7]
 328 01ce DB88     		ldrh	r3, [r3, #6]
 329 01d0 002B     		cmp	r3, #0
 330 01d2 0CD0     		beq	.L13
 266:../Generated_Code/I2C2.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 331              		.loc 1 266 0
 332 01d4 3B68     		ldr	r3, [r7]
 333 01d6 DB88     		ldrh	r3, [r3, #6]
 334 01d8 012B     		cmp	r3, #1
 335 01da 1FD1     		bne	.L14
 267:../Generated_Code/I2C2.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 336              		.loc 1 267 0
 337 01dc 354B     		ldr	r3, .L16+4
 338 01de 354A     		ldr	r2, .L16+4
 339 01e0 9278     		ldrb	r2, [r2, #2]
 340 01e2 D2B2     		uxtb	r2, r2
 341 01e4 0821     		mov	r1, #8
 342 01e6 0A43     		orr	r2, r1
 343 01e8 D2B2     		uxtb	r2, r2
 344 01ea 9A70     		strb	r2, [r3, #2]
 345 01ec 16E0     		b	.L14
 346              	.L13:
 268:../Generated_Code/I2C2.c ****         }
 269:../Generated_Code/I2C2.c ****       } else {
 270:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 347              		.loc 1 270 0
 348 01ee 3B68     		ldr	r3, [r7]
 349 01f0 1B78     		ldrb	r3, [r3]
 350 01f2 0122     		mov	r2, #1
 351 01f4 9343     		bic	r3, r2
 352 01f6 DAB2     		uxtb	r2, r3
 353 01f8 3B68     		ldr	r3, [r7]
 354 01fa 1A70     		strb	r2, [r3]
 271:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 355              		.loc 1 271 0
 356 01fc 2D4B     		ldr	r3, .L16+4
 357 01fe 2D4A     		ldr	r2, .L16+4
 358 0200 9278     		ldrb	r2, [r2, #2]
 359 0202 D2B2     		uxtb	r2, r2
 360 0204 2021     		mov	r1, #32
 361 0206 8A43     		bic	r2, r1
 362 0208 D2B2     		uxtb	r2, r2
 363 020a 9A70     		strb	r2, [r3, #2]
 272:../Generated_Code/I2C2.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 364              		.loc 1 272 0
 365 020c 294B     		ldr	r3, .L16+4
 366 020e 294A     		ldr	r2, .L16+4
 367 0210 9278     		ldrb	r2, [r2, #2]
 368 0212 D2B2     		uxtb	r2, r2
 369 0214 0821     		mov	r1, #8
 370 0216 8A43     		bic	r2, r1
 371 0218 D2B2     		uxtb	r2, r2
 372 021a 9A70     		strb	r2, [r3, #2]
 373              	.L14:
 273:../Generated_Code/I2C2.c ****       }
 274:../Generated_Code/I2C2.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Receive character */
 374              		.loc 1 274 0
 375 021c 3B68     		ldr	r3, [r7]
 376 021e 9B68     		ldr	r3, [r3, #8]
 377 0220 244A     		ldr	r2, .L16+4
 378 0222 1279     		ldrb	r2, [r2, #4]
 379 0224 D2B2     		uxtb	r2, r2
 380 0226 1A70     		strb	r2, [r3]
 381 0228 5A1C     		add	r2, r3, #1
 382 022a 3B68     		ldr	r3, [r7]
 383 022c 9A60     		str	r2, [r3, #8]
 275:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 384              		.loc 1 275 0
 385 022e 3B68     		ldr	r3, [r7]
 386 0230 DB88     		ldrh	r3, [r3, #6]
 387 0232 002B     		cmp	r3, #0
 388 0234 27D1     		bne	.L5
 276:../Generated_Code/I2C2.c ****         I2C2_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived event 
 389              		.loc 1 276 0
 390 0236 3B68     		ldr	r3, [r7]
 391 0238 5B69     		ldr	r3, [r3, #20]
 392 023a 181C     		mov	r0, r3
 393 023c FFF7FEFF 		bl	I2C2_OnMasterBlockReceived
 394 0240 21E0     		b	.L5
 395              	.L2:
 277:../Generated_Code/I2C2.c ****       }
 278:../Generated_Code/I2C2.c ****     }
 279:../Generated_Code/I2C2.c ****   } else {
 280:../Generated_Code/I2C2.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 396              		.loc 1 280 0
 397 0242 221C     		mov	r2, r4
 398 0244 1023     		mov	r3, #16
 399 0246 1340     		and	r3, r2
 400 0248 1DD0     		beq	.L5
 281:../Generated_Code/I2C2.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 401              		.loc 1 281 0
 402 024a 3B68     		ldr	r3, [r7]
 403 024c 0022     		mov	r2, #0
 404 024e 9A81     		strh	r2, [r3, #12]
 282:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 405              		.loc 1 282 0
 406 0250 3B68     		ldr	r3, [r7]
 407 0252 0022     		mov	r2, #0
 408 0254 DA80     		strh	r2, [r3, #6]
 283:../Generated_Code/I2C2.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 409              		.loc 1 283 0
 410 0256 3B68     		ldr	r3, [r7]
 411 0258 0122     		mov	r2, #1
 412 025a 5A70     		strb	r2, [r3, #1]
 284:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 413              		.loc 1 284 0
 414 025c 3B68     		ldr	r3, [r7]
 415 025e 1B78     		ldrb	r3, [r3]
 416 0260 0122     		mov	r2, #1
 417 0262 9343     		bic	r3, r2
 418 0264 DAB2     		uxtb	r2, r3
 419 0266 3B68     		ldr	r3, [r7]
 420 0268 1A70     		strb	r2, [r3]
 285:../Generated_Code/I2C2.c ****       I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 421              		.loc 1 285 0
 422 026a 124B     		ldr	r3, .L16+4
 423 026c 114A     		ldr	r2, .L16+4
 424 026e 9278     		ldrb	r2, [r2, #2]
 425 0270 D2B2     		uxtb	r2, r2
 426 0272 1021     		mov	r1, #16
 427 0274 8A43     		bic	r2, r1
 428 0276 D2B2     		uxtb	r2, r2
 429 0278 9A70     		strb	r2, [r3, #2]
 286:../Generated_Code/I2C2.c ****       ErrorMask |= LDD_I2C_ARBIT_LOST; /* Set the ArbitLost error mask */
 430              		.loc 1 286 0
 431 027a BB1D     		add	r3, r7, #6
 432 027c BA1D     		add	r2, r7, #6
 433 027e 1288     		ldrh	r2, [r2]
 434 0280 0421     		mov	r1, #4
 435 0282 0A43     		orr	r2, r1
 436 0284 1A80     		strh	r2, [r3]
 437              	.L5:
 287:../Generated_Code/I2C2.c ****     }
 288:../Generated_Code/I2C2.c ****   }
 289:../Generated_Code/I2C2.c ****   if (ErrorMask != 0x00U) {            /* Is any error mask set? */
 438              		.loc 1 289 0
 439 0286 BB1D     		add	r3, r7, #6
 440 0288 1B88     		ldrh	r3, [r3]
 441 028a 002B     		cmp	r3, #0
 442 028c 0CD0     		beq	.L1
 290:../Generated_Code/I2C2.c ****     DeviceDataPrv->ErrorMask |= ErrorMask; /* Update list of error mask value */
 443              		.loc 1 290 0
 444 028e 3B68     		ldr	r3, [r7]
 445 0290 5A88     		ldrh	r2, [r3, #2]
 446 0292 BB1D     		add	r3, r7, #6
 447 0294 1B88     		ldrh	r3, [r3]
 448 0296 1343     		orr	r3, r2
 449 0298 9AB2     		uxth	r2, r3
 450 029a 3B68     		ldr	r3, [r7]
 451 029c 5A80     		strh	r2, [r3, #2]
 291:../Generated_Code/I2C2.c ****     I2C2_OnError(DeviceDataPrv->UserData); /* If yes then invoke user event */
 452              		.loc 1 291 0
 453 029e 3B68     		ldr	r3, [r7]
 454 02a0 5B69     		ldr	r3, [r3, #20]
 455 02a2 181C     		mov	r0, r3
 456 02a4 FFF7FEFF 		bl	I2C2_OnError
 457              	.L1:
 292:../Generated_Code/I2C2.c ****   }
 293:../Generated_Code/I2C2.c **** }
 458              		.loc 1 293 0
 459 02a8 BD46     		mov	sp, r7
 460 02aa 03B0     		add	sp, sp, #12
 461              		@ sp needed for prologue
 462 02ac 90BD     		pop	{r4, r7, pc}
 463              	.L17:
 464 02ae C046     		.align	2
 465              	.L16:
 466 02b0 00000000 		.word	INT_I2C0__DEFAULT_RTOS_ISRPARAM
 467 02b4 00600640 		.word	1074159616
 468              		.cfi_endproc
 469              	.LFE0:
 471              		.section	.text.I2C2_Init,"ax",%progbits
 472              		.align	2
 473              		.global	I2C2_Init
 474              		.code	16
 475              		.thumb_func
 477              	I2C2_Init:
 478              	.LFB1:
 294:../Generated_Code/I2C2.c **** 
 295:../Generated_Code/I2C2.c **** /*
 296:../Generated_Code/I2C2.c **** ** ===================================================================
 297:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Init (component I2C_LDD)
 298:../Generated_Code/I2C2.c **** */
 299:../Generated_Code/I2C2.c **** /*!
 300:../Generated_Code/I2C2.c **** **     @brief
 301:../Generated_Code/I2C2.c **** **         Initializes the device. Allocates memory for the device data
 302:../Generated_Code/I2C2.c **** **         structure, allocates interrupt vectors and sets interrupt
 303:../Generated_Code/I2C2.c **** **         priority, sets pin routing, sets timing, etc.
 304:../Generated_Code/I2C2.c **** **         If the "Enable in init. code" is set to "yes" value then the
 305:../Generated_Code/I2C2.c **** **         device is also enabled(see the description of the Enable()
 306:../Generated_Code/I2C2.c **** **         method). In this case the Enable() method is not necessary
 307:../Generated_Code/I2C2.c **** **         and needn't to be generated. 
 308:../Generated_Code/I2C2.c **** **         This method can be called only once. Before the second call
 309:../Generated_Code/I2C2.c **** **         of Init() the Deinit() must be called first.
 310:../Generated_Code/I2C2.c **** **     @param
 311:../Generated_Code/I2C2.c **** **         UserDataPtr     - Pointer to the user or
 312:../Generated_Code/I2C2.c **** **                           RTOS specific data. This pointer will be
 313:../Generated_Code/I2C2.c **** **                           passed as an event or callback parameter.
 314:../Generated_Code/I2C2.c **** **     @return
 315:../Generated_Code/I2C2.c **** **                         - Pointer to the device data structure. 
 316:../Generated_Code/I2C2.c **** */
 317:../Generated_Code/I2C2.c **** /* ===================================================================*/
 318:../Generated_Code/I2C2.c **** LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr)
 319:../Generated_Code/I2C2.c **** {
 479              		.loc 1 319 0
 480              		.cfi_startproc
 481 0000 80B5     		push	{r7, lr}
 482              	.LCFI3:
 483              		.cfi_def_cfa_offset 8
 484              		.cfi_offset 7, -8
 485              		.cfi_offset 14, -4
 486 0002 84B0     		sub	sp, sp, #16
 487              	.LCFI4:
 488              		.cfi_def_cfa_offset 24
 489 0004 00AF     		add	r7, sp, #0
 490              	.LCFI5:
 491              		.cfi_def_cfa_register 7
 492 0006 7860     		str	r0, [r7, #4]
 320:../Generated_Code/I2C2.c ****   /* Allocate HAL device structure */
 321:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv;
 322:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 323:../Generated_Code/I2C2.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 493              		.loc 1 323 0
 494 0008 3B4B     		ldr	r3, .L20
 495 000a FB60     		str	r3, [r7, #12]
 324:../Generated_Code/I2C2.c **** 
 325:../Generated_Code/I2C2.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 496              		.loc 1 325 0
 497 000c FB68     		ldr	r3, [r7, #12]
 498 000e 7A68     		ldr	r2, [r7, #4]
 499 0010 5A61     		str	r2, [r3, #20]
 326:../Generated_Code/I2C2.c **** 
 327:../Generated_Code/I2C2.c ****   /* Allocate interrupt vector */
 328:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 329:../Generated_Code/I2C2.c ****   INT_I2C0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
 500              		.loc 1 329 0
 501 0012 3A4B     		ldr	r3, .L20+4
 502 0014 FA68     		ldr	r2, [r7, #12]
 503 0016 1A60     		str	r2, [r3]
 330:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag = ADDR_7;     /* Reset all flags start with 7-bit address mode */
 504              		.loc 1 330 0
 505 0018 FB68     		ldr	r3, [r7, #12]
 506 001a 2022     		mov	r2, #32
 507 001c 1A70     		strb	r2, [r3]
 331:../Generated_Code/I2C2.c ****   DeviceDataPrv->SlaveAddr = 0x3AU;    /* Set variable for slave address */
 508              		.loc 1 331 0
 509 001e FB68     		ldr	r3, [r7, #12]
 510 0020 3A22     		mov	r2, #58
 511 0022 1A71     		strb	r2, [r3, #4]
 332:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 512              		.loc 1 332 0
 513 0024 FB68     		ldr	r3, [r7, #12]
 514 0026 0122     		mov	r2, #1
 515 0028 5A70     		strb	r2, [r3, #1]
 333:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 516              		.loc 1 333 0
 517 002a FB68     		ldr	r3, [r7, #12]
 518 002c 0022     		mov	r2, #0
 519 002e DA80     		strh	r2, [r3, #6]
 334:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 520              		.loc 1 334 0
 521 0030 FB68     		ldr	r3, [r7, #12]
 522 0032 0022     		mov	r2, #0
 523 0034 9A81     		strh	r2, [r3, #12]
 335:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;    /* Clear variable for errors mask value */
 524              		.loc 1 335 0
 525 0036 FB68     		ldr	r3, [r7, #12]
 526 0038 0022     		mov	r2, #0
 527 003a 5A80     		strh	r2, [r3, #2]
 336:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C0=1 */
 337:../Generated_Code/I2C2.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;
 528              		.loc 1 337 0
 529 003c 304A     		ldr	r2, .L20+8
 530 003e 3049     		ldr	r1, .L20+8
 531 0040 304B     		ldr	r3, .L20+12
 532 0042 CB58     		ldr	r3, [r1, r3]
 533 0044 4021     		mov	r1, #64
 534 0046 1943     		orr	r1, r3
 535 0048 2E4B     		ldr	r3, .L20+12
 536 004a D150     		str	r1, [r2, r3]
 338:../Generated_Code/I2C2.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 339:../Generated_Code/I2C2.c ****   I2C0_C1 = 0x00U;                     /* Clear control register */
 537              		.loc 1 339 0
 538 004c 2E4B     		ldr	r3, .L20+16
 539 004e 0022     		mov	r2, #0
 540 0050 9A70     		strb	r2, [r3, #2]
 340:../Generated_Code/I2C2.c ****   /* I2C0_FLT: SHEN=0,STOPF=1,STOPIE=0,FLT=0 */
 341:../Generated_Code/I2C2.c ****   I2C0_FLT = (I2C_FLT_STOPF_MASK | I2C_FLT_FLT(0x00)); /* Clear bus status interrupt flags */
 541              		.loc 1 341 0
 542 0052 2D4B     		ldr	r3, .L20+16
 543 0054 4022     		mov	r2, #64
 544 0056 9A71     		strb	r2, [r3, #6]
 342:../Generated_Code/I2C2.c ****   /* I2C0_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 343:../Generated_Code/I2C2.c ****   I2C0_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 545              		.loc 1 343 0
 546 0058 2B4B     		ldr	r3, .L20+16
 547 005a 0222     		mov	r2, #2
 548 005c DA70     		strb	r2, [r3, #3]
 344:../Generated_Code/I2C2.c ****   /* PORTE_PCR25: ISF=0,MUX=5 */
 345:../Generated_Code/I2C2.c ****   PORTE_PCR25 = (uint32_t)((PORTE_PCR25 & (uint32_t)~(uint32_t)(
 549              		.loc 1 345 0
 550 005e 2B4B     		ldr	r3, .L20+20
 551 0060 2A4A     		ldr	r2, .L20+20
 552 0062 516E     		ldr	r1, [r2, #100]
 553 0064 2A4A     		ldr	r2, .L20+24
 554 0066 0A40     		and	r2, r1
 555 0068 A021     		mov	r1, #160
 556 006a C900     		lsl	r1, r1, #3
 557 006c 0A43     		orr	r2, r1
 558 006e 5A66     		str	r2, [r3, #100]
 346:../Generated_Code/I2C2.c ****                  PORT_PCR_ISF_MASK |
 347:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x02)
 348:../Generated_Code/I2C2.c ****                 )) | (uint32_t)(
 349:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x05)
 350:../Generated_Code/I2C2.c ****                 ));
 351:../Generated_Code/I2C2.c ****   /* PORTE_PCR24: ISF=0,MUX=5 */
 352:../Generated_Code/I2C2.c ****   PORTE_PCR24 = (uint32_t)((PORTE_PCR24 & (uint32_t)~(uint32_t)(
 559              		.loc 1 352 0
 560 0070 264B     		ldr	r3, .L20+20
 561 0072 264A     		ldr	r2, .L20+20
 562 0074 116E     		ldr	r1, [r2, #96]
 563 0076 264A     		ldr	r2, .L20+24
 564 0078 0A40     		and	r2, r1
 565 007a A021     		mov	r1, #160
 566 007c C900     		lsl	r1, r1, #3
 567 007e 0A43     		orr	r2, r1
 568 0080 1A66     		str	r2, [r3, #96]
 353:../Generated_Code/I2C2.c ****                  PORT_PCR_ISF_MASK |
 354:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x02)
 355:../Generated_Code/I2C2.c ****                 )) | (uint32_t)(
 356:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x05)
 357:../Generated_Code/I2C2.c ****                 ));
 358:../Generated_Code/I2C2.c ****   /* NVIC_IPR2: PRI_8=0x80 */
 359:../Generated_Code/I2C2.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 569              		.loc 1 359 0
 570 0082 244A     		ldr	r2, .L20+28
 571 0084 2349     		ldr	r1, .L20+28
 572 0086 C223     		mov	r3, #194
 573 0088 9B00     		lsl	r3, r3, #2
 574 008a CB58     		ldr	r3, [r1, r3]
 575 008c FF21     		mov	r1, #255
 576 008e 8B43     		bic	r3, r1
 577 0090 8021     		mov	r1, #128
 578 0092 1943     		orr	r1, r3
 579 0094 C223     		mov	r3, #194
 580 0096 9B00     		lsl	r3, r3, #2
 581 0098 D150     		str	r1, [r2, r3]
 360:../Generated_Code/I2C2.c ****                NVIC_IP_PRI_8(0x7F)
 361:../Generated_Code/I2C2.c ****               )) | (uint32_t)(
 362:../Generated_Code/I2C2.c ****                NVIC_IP_PRI_8(0x80)
 363:../Generated_Code/I2C2.c ****               ));
 364:../Generated_Code/I2C2.c ****   /* NVIC_ISER: SETENA|=0x0100 */
 365:../Generated_Code/I2C2.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0100);
 582              		.loc 1 365 0
 583 009a 1E4B     		ldr	r3, .L20+28
 584 009c 1D4A     		ldr	r2, .L20+28
 585 009e 1268     		ldr	r2, [r2]
 586 00a0 8021     		mov	r1, #128
 587 00a2 4900     		lsl	r1, r1, #1
 588 00a4 0A43     		orr	r2, r1
 589 00a6 1A60     		str	r2, [r3]
 366:../Generated_Code/I2C2.c ****   /* I2C0_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 367:../Generated_Code/I2C2.c ****   I2C0_C2 = I2C_C2_AD(0x00);
 590              		.loc 1 367 0
 591 00a8 174B     		ldr	r3, .L20+16
 592 00aa 0022     		mov	r2, #0
 593 00ac 5A71     		strb	r2, [r3, #5]
 368:../Generated_Code/I2C2.c ****   /* I2C0_FLT: SHEN=0,STOPF=0,STOPIE=0,FLT=0 */
 369:../Generated_Code/I2C2.c ****   I2C0_FLT = I2C_FLT_FLT(0x00);        /* Set glitch filter register */
 594              		.loc 1 369 0
 595 00ae 164B     		ldr	r3, .L20+16
 596 00b0 0022     		mov	r2, #0
 597 00b2 9A71     		strb	r2, [r3, #6]
 370:../Generated_Code/I2C2.c ****   /* I2C0_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 371:../Generated_Code/I2C2.c ****   I2C0_SMB = I2C_SMB_SLTF_MASK;
 598              		.loc 1 371 0
 599 00b4 144B     		ldr	r3, .L20+16
 600 00b6 0822     		mov	r2, #8
 601 00b8 1A72     		strb	r2, [r3, #8]
 372:../Generated_Code/I2C2.c ****   /* I2C0_F: MULT=0,ICR=0 */
 373:../Generated_Code/I2C2.c ****   I2C0_F = (I2C_F_MULT(0x00) | I2C_F_ICR(0x00)); /* Set prescaler bits */
 602              		.loc 1 373 0
 603 00ba 134B     		ldr	r3, .L20+16
 604 00bc 0022     		mov	r2, #0
 605 00be 5A70     		strb	r2, [r3, #1]
 374:../Generated_Code/I2C2.c ****   I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_ENABLE); /* Enable device */
 606              		.loc 1 374 0
 607 00c0 114B     		ldr	r3, .L20+16
 608 00c2 114A     		ldr	r2, .L20+16
 609 00c4 9278     		ldrb	r2, [r2, #2]
 610 00c6 D2B2     		uxtb	r2, r2
 611 00c8 D2B2     		uxtb	r2, r2
 612 00ca 8021     		mov	r1, #128
 613 00cc 4942     		neg	r1, r1
 614 00ce 0A43     		orr	r2, r1
 615 00d0 D2B2     		uxtb	r2, r2
 616 00d2 D2B2     		uxtb	r2, r2
 617 00d4 9A70     		strb	r2, [r3, #2]
 375:../Generated_Code/I2C2.c ****   I2C_PDD_EnableInterrupt(I2C0_BASE_PTR); /* Enable interrupt */
 618              		.loc 1 375 0
 619 00d6 0C4B     		ldr	r3, .L20+16
 620 00d8 0B4A     		ldr	r2, .L20+16
 621 00da 9278     		ldrb	r2, [r2, #2]
 622 00dc D2B2     		uxtb	r2, r2
 623 00de 4021     		mov	r1, #64
 624 00e0 0A43     		orr	r2, r1
 625 00e2 D2B2     		uxtb	r2, r2
 626 00e4 9A70     		strb	r2, [r3, #2]
 376:../Generated_Code/I2C2.c ****   /* Registration of the device structure */
 377:../Generated_Code/I2C2.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID,DeviceDataPrv);
 627              		.loc 1 377 0
 628 00e6 0C4B     		ldr	r3, .L20+32
 629 00e8 FA68     		ldr	r2, [r7, #12]
 630 00ea DA60     		str	r2, [r3, #12]
 378:../Generated_Code/I2C2.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 631              		.loc 1 378 0
 632 00ec FB68     		ldr	r3, [r7, #12]
 379:../Generated_Code/I2C2.c **** }
 633              		.loc 1 379 0
 634 00ee 181C     		mov	r0, r3
 635 00f0 BD46     		mov	sp, r7
 636 00f2 04B0     		add	sp, sp, #16
 637              		@ sp needed for prologue
 638 00f4 80BD     		pop	{r7, pc}
 639              	.L21:
 640 00f6 C046     		.align	2
 641              	.L20:
 642 00f8 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 643 00fc 00000000 		.word	INT_I2C0__DEFAULT_RTOS_ISRPARAM
 644 0100 00700440 		.word	1074032640
 645 0104 34100000 		.word	4148
 646 0108 00600640 		.word	1074159616
 647 010c 00D00440 		.word	1074057216
 648 0110 FFF8FFFE 		.word	-16779009
 649 0114 00E100E0 		.word	-536813312
 650 0118 00000000 		.word	PE_LDD_DeviceDataList
 651              		.cfi_endproc
 652              	.LFE1:
 654              		.section	.text.I2C2_Deinit,"ax",%progbits
 655              		.align	2
 656              		.global	I2C2_Deinit
 657              		.code	16
 658              		.thumb_func
 660              	I2C2_Deinit:
 661              	.LFB2:
 380:../Generated_Code/I2C2.c **** 
 381:../Generated_Code/I2C2.c **** /*
 382:../Generated_Code/I2C2.c **** ** ===================================================================
 383:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Deinit (component I2C_LDD)
 384:../Generated_Code/I2C2.c **** */
 385:../Generated_Code/I2C2.c **** /*!
 386:../Generated_Code/I2C2.c **** **     @brief
 387:../Generated_Code/I2C2.c **** **         Deinitializes the device. Switches off the device, frees the
 388:../Generated_Code/I2C2.c **** **         device data structure memory, interrupts vectors, etc.
 389:../Generated_Code/I2C2.c **** **     @param
 390:../Generated_Code/I2C2.c **** **         DeviceDataPtr   - Device data structure
 391:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 392:../Generated_Code/I2C2.c **** */
 393:../Generated_Code/I2C2.c **** /* ===================================================================*/
 394:../Generated_Code/I2C2.c **** void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr)
 395:../Generated_Code/I2C2.c **** {
 662              		.loc 1 395 0
 663              		.cfi_startproc
 664 0000 80B5     		push	{r7, lr}
 665              	.LCFI6:
 666              		.cfi_def_cfa_offset 8
 667              		.cfi_offset 7, -8
 668              		.cfi_offset 14, -4
 669 0002 82B0     		sub	sp, sp, #8
 670              	.LCFI7:
 671              		.cfi_def_cfa_offset 16
 672 0004 00AF     		add	r7, sp, #0
 673              	.LCFI8:
 674              		.cfi_def_cfa_register 7
 675 0006 7860     		str	r0, [r7, #4]
 396:../Generated_Code/I2C2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 397:../Generated_Code/I2C2.c **** 
 398:../Generated_Code/I2C2.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 399:../Generated_Code/I2C2.c ****   I2C0_C1 = 0x00U;                     /* Reset I2C Control register */
 676              		.loc 1 399 0
 677 0008 094B     		ldr	r3, .L23
 678 000a 0022     		mov	r2, #0
 679 000c 9A70     		strb	r2, [r3, #2]
 400:../Generated_Code/I2C2.c ****   /* Restoring the interrupt vector */
 401:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 402:../Generated_Code/I2C2.c ****   /* Unregistration of the device structure */
 403:../Generated_Code/I2C2.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID);
 680              		.loc 1 403 0
 681 000e 094B     		ldr	r3, .L23+4
 682 0010 0022     		mov	r2, #0
 683 0012 DA60     		str	r2, [r3, #12]
 404:../Generated_Code/I2C2.c ****   /* Deallocation of the device structure */
 405:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 406:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C0=0 */
 407:../Generated_Code/I2C2.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_I2C0_MASK);
 684              		.loc 1 407 0
 685 0014 084A     		ldr	r2, .L23+8
 686 0016 0849     		ldr	r1, .L23+8
 687 0018 084B     		ldr	r3, .L23+12
 688 001a CB58     		ldr	r3, [r1, r3]
 689 001c 4021     		mov	r1, #64
 690 001e 181C     		mov	r0, r3
 691 0020 8843     		bic	r0, r1
 692 0022 011C     		mov	r1, r0
 693 0024 054B     		ldr	r3, .L23+12
 694 0026 D150     		str	r1, [r2, r3]
 408:../Generated_Code/I2C2.c **** }
 695              		.loc 1 408 0
 696 0028 BD46     		mov	sp, r7
 697 002a 02B0     		add	sp, sp, #8
 698              		@ sp needed for prologue
 699 002c 80BD     		pop	{r7, pc}
 700              	.L24:
 701 002e C046     		.align	2
 702              	.L23:
 703 0030 00600640 		.word	1074159616
 704 0034 00000000 		.word	PE_LDD_DeviceDataList
 705 0038 00700440 		.word	1074032640
 706 003c 34100000 		.word	4148
 707              		.cfi_endproc
 708              	.LFE2:
 710              		.section	.text.I2C2_MasterSendBlock,"ax",%progbits
 711              		.align	2
 712              		.global	I2C2_MasterSendBlock
 713              		.code	16
 714              		.thumb_func
 716              	I2C2_MasterSendBlock:
 717              	.LFB3:
 409:../Generated_Code/I2C2.c **** 
 410:../Generated_Code/I2C2.c **** /*
 411:../Generated_Code/I2C2.c **** ** ===================================================================
 412:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterSendBlock (component I2C_LDD)
 413:../Generated_Code/I2C2.c **** */
 414:../Generated_Code/I2C2.c **** /*!
 415:../Generated_Code/I2C2.c **** **     @brief
 416:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 417:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 418:../Generated_Code/I2C2.c **** **         the I2C bus and then writes the block of characters to the
 419:../Generated_Code/I2C2.c **** **         bus. The slave address must be specified before, by the
 420:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 421:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 422:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that transmission was
 423:../Generated_Code/I2C2.c **** **         successful. The state of transmission is detectable by means
 424:../Generated_Code/I2C2.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 425:../Generated_Code/I2C2.c **** **         are not copied to an internal buffer and remains in the
 426:../Generated_Code/I2C2.c **** **         original location. Therefore the content of the buffer
 427:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 428:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 429:../Generated_Code/I2C2.c **** **         the transmission. This method is available only for the
 430:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 431:../Generated_Code/I2C2.c **** **     @param
 432:../Generated_Code/I2C2.c **** **         DeviceDataPtr   - Device data structure
 433:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 434:../Generated_Code/I2C2.c **** **     @param
 435:../Generated_Code/I2C2.c **** **         BufferPtr       - Pointer to the block of data
 436:../Generated_Code/I2C2.c **** **                           to send.
 437:../Generated_Code/I2C2.c **** **     @param
 438:../Generated_Code/I2C2.c **** **         Size            - Size of the data block.
 439:../Generated_Code/I2C2.c **** **     @param
 440:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 441:../Generated_Code/I2C2.c **** **                           Stop condition
 442:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 443:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 444:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 445:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 446:../Generated_Code/I2C2.c **** **     @return
 447:../Generated_Code/I2C2.c **** **                         - Error code, possible codes:
 448:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 449:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 450:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 451:../Generated_Code/I2C2.c **** **                           the active clock configuration
 452:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The I2C device is now running
 453:../Generated_Code/I2C2.c **** */
 454:../Generated_Code/I2C2.c **** /* ===================================================================*/
 455:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TSize
 456:../Generated_Code/I2C2.c **** {
 718              		.loc 1 456 0
 719              		.cfi_startproc
 720 0000 80B5     		push	{r7, lr}
 721              	.LCFI9:
 722              		.cfi_def_cfa_offset 8
 723              		.cfi_offset 7, -8
 724              		.cfi_offset 14, -4
 725 0002 86B0     		sub	sp, sp, #24
 726              	.LCFI10:
 727              		.cfi_def_cfa_offset 32
 728 0004 00AF     		add	r7, sp, #0
 729              	.LCFI11:
 730              		.cfi_def_cfa_register 7
 731 0006 F860     		str	r0, [r7, #12]
 732 0008 B960     		str	r1, [r7, #8]
 733 000a 111C     		mov	r1, r2
 734 000c 1A1C     		mov	r2, r3
 735 000e BB1D     		add	r3, r7, #6
 736 0010 1980     		strh	r1, [r3]
 737 0012 7B1D     		add	r3, r7, #5
 738 0014 1A70     		strb	r2, [r3]
 457:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 739              		.loc 1 457 0
 740 0016 FB68     		ldr	r3, [r7, #12]
 741 0018 7B61     		str	r3, [r7, #20]
 458:../Generated_Code/I2C2.c **** 
 459:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 742              		.loc 1 459 0
 743 001a BB1D     		add	r3, r7, #6
 744 001c 1B88     		ldrh	r3, [r3]
 745 001e 002B     		cmp	r3, #0
 746 0020 01D1     		bne	.L26
 460:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 747              		.loc 1 460 0
 748 0022 0023     		mov	r3, #0
 749 0024 B0E0     		b	.L27
 750              	.L26:
 461:../Generated_Code/I2C2.c ****   }
 462:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 751              		.loc 1 462 0
 752 0026 7B69     		ldr	r3, [r7, #20]
 753 0028 5B78     		ldrb	r3, [r3, #1]
 754 002a 012B     		cmp	r3, #1
 755 002c 12D1     		bne	.L28
 463:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 756              		.loc 1 463 0
 757 002e 584B     		ldr	r3, .L39
 758 0030 DB78     		ldrb	r3, [r3, #3]
 759 0032 DBB2     		uxtb	r3, r3
 760 0034 1A1C     		mov	r2, r3
 761 0036 2023     		mov	r3, #32
 762 0038 1340     		and	r3, r2
 763 003a 09D1     		bne	.L29
 464:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 764              		.loc 1 464 0
 765 003c 7B69     		ldr	r3, [r7, #20]
 766 003e 1B78     		ldrb	r3, [r3]
 767 0040 1A1C     		mov	r2, r3
 768 0042 0123     		mov	r3, #1
 769 0044 1340     		and	r3, r2
 463:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 770              		.loc 1 463 0
 771 0046 03D1     		bne	.L29
 465:../Generated_Code/I2C2.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 772              		.loc 1 465 0
 773 0048 7B69     		ldr	r3, [r7, #20]
 774 004a 9B89     		ldrh	r3, [r3, #12]
 464:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 775              		.loc 1 464 0
 776 004c 002B     		cmp	r3, #0
 777 004e 0DD0     		beq	.L30
 778              	.L29:
 466:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 779              		.loc 1 466 0
 780 0050 0823     		mov	r3, #8
 781 0052 99E0     		b	.L27
 782              	.L28:
 467:../Generated_Code/I2C2.c ****     }
 468:../Generated_Code/I2C2.c ****   } else {
 469:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 783              		.loc 1 469 0
 784 0054 7B69     		ldr	r3, [r7, #20]
 785 0056 1B78     		ldrb	r3, [r3]
 786 0058 1A1C     		mov	r2, r3
 787 005a 0123     		mov	r3, #1
 788 005c 1340     		and	r3, r2
 789 005e 03D1     		bne	.L31
 470:../Generated_Code/I2C2.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 790              		.loc 1 470 0
 791 0060 7B69     		ldr	r3, [r7, #20]
 792 0062 9B89     		ldrh	r3, [r3, #12]
 469:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 793              		.loc 1 469 0
 794 0064 002B     		cmp	r3, #0
 795 0066 01D0     		beq	.L30
 796              	.L31:
 471:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 797              		.loc 1 471 0
 798 0068 0823     		mov	r3, #8
 799 006a 8DE0     		b	.L27
 800              	.L30:
 801              	.LBB2:
 472:../Generated_Code/I2C2.c ****     }
 473:../Generated_Code/I2C2.c ****   }
 474:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 475:../Generated_Code/I2C2.c ****   EnterCritical();
 802              		.loc 1 475 0
 803 006c 3B1C     		mov	r3, r7
 804 006e 1333     		add	r3, r3, #19
 805              	@ 475 "../Generated_Code/I2C2.c" 1
 806 0070 EFF31080 		MRS R0, PRIMASK
 807 0074 72B6     		CPSID i
 808 0076 1870     		STRB R0, [r3]
 809              	@ 0 "" 2
 810              		.code	16
 811 0078 464B     		ldr	r3, .L39+4
 812 007a 1B78     		ldrb	r3, [r3]
 813 007c DBB2     		uxtb	r3, r3
 814 007e 0133     		add	r3, r3, #1
 815 0080 DBB2     		uxtb	r3, r3
 816 0082 444A     		ldr	r2, .L39+4
 817 0084 191C     		add	r1, r3, #0
 818 0086 1170     		strb	r1, [r2]
 819 0088 012B     		cmp	r3, #1
 820 008a 04D1     		bne	.L32
 821              		.loc 1 475 0 is_stmt 0
 822 008c 3B1C     		mov	r3, r7
 823 008e 1333     		add	r3, r3, #19
 824 0090 1A78     		ldrb	r2, [r3]
 825 0092 414B     		ldr	r3, .L39+8
 826 0094 1A70     		strb	r2, [r3]
 827              	.L32:
 828              	.LBE2:
 476:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 829              		.loc 1 476 0 is_stmt 1
 830 0096 7B69     		ldr	r3, [r7, #20]
 831 0098 1B78     		ldrb	r3, [r3]
 832 009a 0122     		mov	r2, #1
 833 009c 1343     		orr	r3, r2
 834 009e DAB2     		uxtb	r2, r3
 835 00a0 7B69     		ldr	r3, [r7, #20]
 836 00a2 1A70     		strb	r2, [r3]
 477:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 837              		.loc 1 477 0
 838 00a4 7B69     		ldr	r3, [r7, #20]
 839 00a6 BA68     		ldr	r2, [r7, #8]
 840 00a8 1A61     		str	r2, [r3, #16]
 478:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 841              		.loc 1 478 0
 842 00aa 7B69     		ldr	r3, [r7, #20]
 843 00ac BA1D     		add	r2, r7, #6
 844 00ae 1288     		ldrh	r2, [r2]
 845 00b0 9A81     		strh	r2, [r3, #12]
 479:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 846              		.loc 1 479 0
 847 00b2 7B69     		ldr	r3, [r7, #20]
 848 00b4 7A1D     		add	r2, r7, #5
 849 00b6 1278     		ldrb	r2, [r2]
 850 00b8 5A70     		strb	r2, [r3, #1]
 480:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 851              		.loc 1 480 0
 852 00ba 354B     		ldr	r3, .L39
 853 00bc 344A     		ldr	r2, .L39
 854 00be 9278     		ldrb	r2, [r2, #2]
 855 00c0 D2B2     		uxtb	r2, r2
 856 00c2 D2B2     		uxtb	r2, r2
 857 00c4 1021     		mov	r1, #16
 858 00c6 0A43     		orr	r2, r1
 859 00c8 D2B2     		uxtb	r2, r2
 860 00ca D2B2     		uxtb	r2, r2
 861 00cc 9A70     		strb	r2, [r3, #2]
 481:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 862              		.loc 1 481 0
 863 00ce 304B     		ldr	r3, .L39
 864 00d0 9B78     		ldrb	r3, [r3, #2]
 865 00d2 DBB2     		uxtb	r3, r3
 866 00d4 1A1C     		mov	r2, r3
 867 00d6 2023     		mov	r3, #32
 868 00d8 1340     		and	r3, r2
 869 00da 08D0     		beq	.L33
 482:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 870              		.loc 1 482 0
 871 00dc 2C4B     		ldr	r3, .L39
 872 00de 2C4A     		ldr	r2, .L39
 873 00e0 9278     		ldrb	r2, [r2, #2]
 874 00e2 D2B2     		uxtb	r2, r2
 875 00e4 0421     		mov	r1, #4
 876 00e6 0A43     		orr	r2, r1
 877 00e8 D2B2     		uxtb	r2, r2
 878 00ea 9A70     		strb	r2, [r3, #2]
 879 00ec 09E0     		b	.L34
 880              	.L33:
 483:../Generated_Code/I2C2.c ****   } else {
 484:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 881              		.loc 1 484 0
 882 00ee 284B     		ldr	r3, .L39
 883 00f0 274A     		ldr	r2, .L39
 884 00f2 9278     		ldrb	r2, [r2, #2]
 885 00f4 D2B2     		uxtb	r2, r2
 886 00f6 D2B2     		uxtb	r2, r2
 887 00f8 2021     		mov	r1, #32
 888 00fa 0A43     		orr	r2, r1
 889 00fc D2B2     		uxtb	r2, r2
 890 00fe D2B2     		uxtb	r2, r2
 891 0100 9A70     		strb	r2, [r3, #2]
 892              	.L34:
 485:../Generated_Code/I2C2.c ****   }
 486:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 893              		.loc 1 486 0
 894 0102 7B69     		ldr	r3, [r7, #20]
 895 0104 1B78     		ldrb	r3, [r3]
 896 0106 1A1C     		mov	r2, r3
 897 0108 2023     		mov	r3, #32
 898 010a 1340     		and	r3, r2
 899 010c 0BD0     		beq	.L35
 487:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Only one byte of address will
 900              		.loc 1 487 0
 901 010e 7B69     		ldr	r3, [r7, #20]
 902 0110 1B78     		ldrb	r3, [r3]
 903 0112 0622     		mov	r2, #6
 904 0114 1343     		orr	r3, r2
 905 0116 DAB2     		uxtb	r2, r3
 906 0118 7B69     		ldr	r3, [r7, #20]
 907 011a 1A70     		strb	r2, [r3]
 488:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send slave address */
 908              		.loc 1 488 0
 909 011c 1C4B     		ldr	r3, .L39
 910 011e 7A69     		ldr	r2, [r7, #20]
 911 0120 1279     		ldrb	r2, [r2, #4]
 912 0122 1A71     		strb	r2, [r3, #4]
 913 0124 21E0     		b	.L36
 914              	.L35:
 489:../Generated_Code/I2C2.c ****   } else {
 490:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 915              		.loc 1 490 0
 916 0126 7B69     		ldr	r3, [r7, #20]
 917 0128 1B78     		ldrb	r3, [r3]
 918 012a 1A1C     		mov	r2, r3
 919 012c 1023     		mov	r3, #16
 920 012e 1340     		and	r3, r2
 921 0130 0BD0     		beq	.L37
 491:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 922              		.loc 1 491 0
 923 0132 7B69     		ldr	r3, [r7, #20]
 924 0134 1B78     		ldrb	r3, [r3]
 925 0136 0622     		mov	r2, #6
 926 0138 9343     		bic	r3, r2
 927 013a DAB2     		uxtb	r2, r3
 928 013c 7B69     		ldr	r3, [r7, #20]
 929 013e 1A70     		strb	r2, [r3]
 492:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 930              		.loc 1 492 0
 931 0140 134B     		ldr	r3, .L39
 932 0142 7A69     		ldr	r2, [r7, #20]
 933 0144 5279     		ldrb	r2, [r2, #5]
 934 0146 1A71     		strb	r2, [r3, #4]
 935 0148 0FE0     		b	.L36
 936              	.L37:
 493:../Generated_Code/I2C2.c ****     } else {
 494:../Generated_Code/I2C2.c ****       if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is general call command required ?
 937              		.loc 1 494 0
 938 014a 7B69     		ldr	r3, [r7, #20]
 939 014c 1B78     		ldrb	r3, [r3]
 940 014e 1A1C     		mov	r2, r3
 941 0150 0823     		mov	r3, #8
 942 0152 1340     		and	r3, r2
 943 0154 09D0     		beq	.L36
 495:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= ADDR_COMPLETE; /* Only one byte of address will be sent in genera
 944              		.loc 1 495 0
 945 0156 7B69     		ldr	r3, [r7, #20]
 946 0158 1B78     		ldrb	r3, [r3]
 947 015a 0222     		mov	r2, #2
 948 015c 1343     		orr	r3, r2
 949 015e DAB2     		uxtb	r2, r3
 950 0160 7B69     		ldr	r3, [r7, #20]
 951 0162 1A70     		strb	r2, [r3]
 496:../Generated_Code/I2C2.c ****         I2C_PDD_WriteDataReg(I2C0_BASE_PTR, 0x00U); /* Send general call address */
 952              		.loc 1 496 0
 953 0164 0A4B     		ldr	r3, .L39
 954 0166 0022     		mov	r2, #0
 955 0168 1A71     		strb	r2, [r3, #4]
 956              	.L36:
 497:../Generated_Code/I2C2.c ****       }
 498:../Generated_Code/I2C2.c ****     }
 499:../Generated_Code/I2C2.c ****   }
 500:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 501:../Generated_Code/I2C2.c ****   ExitCritical();
 957              		.loc 1 501 0
 958 016a 0A4B     		ldr	r3, .L39+4
 959 016c 1B78     		ldrb	r3, [r3]
 960 016e DBB2     		uxtb	r3, r3
 961 0170 013B     		sub	r3, r3, #1
 962 0172 DBB2     		uxtb	r3, r3
 963 0174 074A     		ldr	r2, .L39+4
 964 0176 191C     		add	r1, r3, #0
 965 0178 1170     		strb	r1, [r2]
 966 017a 002B     		cmp	r3, #0
 967 017c 03D1     		bne	.L38
 968              		.loc 1 501 0 is_stmt 0
 969 017e 064B     		ldr	r3, .L39+8
 970              	@ 501 "../Generated_Code/I2C2.c" 1
 971 0180 1878     		ldrb r0, [r3]
 972 0182 80F31088 		msr PRIMASK,r0;
 973              		
 974              	@ 0 "" 2
 975              		.code	16
 976              	.L38:
 502:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 977              		.loc 1 502 0 is_stmt 1
 978 0186 0023     		mov	r3, #0
 979              	.L27:
 503:../Generated_Code/I2C2.c **** }
 980              		.loc 1 503 0
 981 0188 181C     		mov	r0, r3
 982 018a BD46     		mov	sp, r7
 983 018c 06B0     		add	sp, sp, #24
 984              		@ sp needed for prologue
 985 018e 80BD     		pop	{r7, pc}
 986              	.L40:
 987              		.align	2
 988              	.L39:
 989 0190 00600640 		.word	1074159616
 990 0194 00000000 		.word	SR_lock
 991 0198 00000000 		.word	SR_reg
 992              		.cfi_endproc
 993              	.LFE3:
 995              		.section	.text.I2C2_MasterReceiveBlock,"ax",%progbits
 996              		.align	2
 997              		.global	I2C2_MasterReceiveBlock
 998              		.code	16
 999              		.thumb_func
 1001              	I2C2_MasterReceiveBlock:
 1002              	.LFB4:
 504:../Generated_Code/I2C2.c **** 
 505:../Generated_Code/I2C2.c **** /*
 506:../Generated_Code/I2C2.c **** ** ===================================================================
 507:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterReceiveBlock (component I2C_LDD)
 508:../Generated_Code/I2C2.c **** */
 509:../Generated_Code/I2C2.c **** /*!
 510:../Generated_Code/I2C2.c **** **     @brief
 511:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 512:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 513:../Generated_Code/I2C2.c **** **         the I2C bus and then receives the block of characters from
 514:../Generated_Code/I2C2.c **** **         the bus. The slave address must be specified before, by the
 515:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 516:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 517:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that reception was
 518:../Generated_Code/I2C2.c **** **         successful. The state of reception is detectable by means of
 519:../Generated_Code/I2C2.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 520:../Generated_Code/I2C2.c **** **         received are not copied to an internal buffer and remains in
 521:../Generated_Code/I2C2.c **** **         the original location. Therefore the content of the buffer
 522:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 523:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 524:../Generated_Code/I2C2.c **** **         of the reception. This method is available only for the
 525:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 526:../Generated_Code/I2C2.c **** **     @param
 527:../Generated_Code/I2C2.c **** **         DeviceDataPtr   - Device data structure
 528:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 529:../Generated_Code/I2C2.c **** **     @param
 530:../Generated_Code/I2C2.c **** **         BufferPtr       - Pointer to a buffer where
 531:../Generated_Code/I2C2.c **** **                           received characters will be stored.
 532:../Generated_Code/I2C2.c **** **     @param
 533:../Generated_Code/I2C2.c **** **         Size            - The size of the block.
 534:../Generated_Code/I2C2.c **** **     @param
 535:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 536:../Generated_Code/I2C2.c **** **                           Stop condition
 537:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 538:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 539:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 540:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 541:../Generated_Code/I2C2.c **** **     @return
 542:../Generated_Code/I2C2.c **** **                         - Error code, possible codes:
 543:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 544:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 545:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 546:../Generated_Code/I2C2.c **** **                           the active clock configuration
 547:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The master device is busy
 548:../Generated_Code/I2C2.c **** **                           ERR_NOTAVAIL - It is not possible to
 549:../Generated_Code/I2C2.c **** **                           receive data if general call address is set.
 550:../Generated_Code/I2C2.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 551:../Generated_Code/I2C2.c **** **                           possible generated on end transmission.
 552:../Generated_Code/I2C2.c **** */
 553:../Generated_Code/I2C2.c **** /* ===================================================================*/
 554:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 555:../Generated_Code/I2C2.c **** {
 1003              		.loc 1 555 0
 1004              		.cfi_startproc
 1005 0000 80B5     		push	{r7, lr}
 1006              	.LCFI12:
 1007              		.cfi_def_cfa_offset 8
 1008              		.cfi_offset 7, -8
 1009              		.cfi_offset 14, -4
 1010 0002 86B0     		sub	sp, sp, #24
 1011              	.LCFI13:
 1012              		.cfi_def_cfa_offset 32
 1013 0004 00AF     		add	r7, sp, #0
 1014              	.LCFI14:
 1015              		.cfi_def_cfa_register 7
 1016 0006 F860     		str	r0, [r7, #12]
 1017 0008 B960     		str	r1, [r7, #8]
 1018 000a 111C     		mov	r1, r2
 1019 000c 1A1C     		mov	r2, r3
 1020 000e BB1D     		add	r3, r7, #6
 1021 0010 1980     		strh	r1, [r3]
 1022 0012 7B1D     		add	r3, r7, #5
 1023 0014 1A70     		strb	r2, [r3]
 556:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1024              		.loc 1 556 0
 1025 0016 FB68     		ldr	r3, [r7, #12]
 1026 0018 7B61     		str	r3, [r7, #20]
 557:../Generated_Code/I2C2.c **** 
 558:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 1027              		.loc 1 558 0
 1028 001a BB1D     		add	r3, r7, #6
 1029 001c 1B88     		ldrh	r3, [r3]
 1030 001e 002B     		cmp	r3, #0
 1031 0020 01D1     		bne	.L42
 559:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 1032              		.loc 1 559 0
 1033 0022 0023     		mov	r3, #0
 1034 0024 B0E0     		b	.L43
 1035              	.L42:
 560:../Generated_Code/I2C2.c ****   }
 561:../Generated_Code/I2C2.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 1036              		.loc 1 561 0
 1037 0026 7B1D     		add	r3, r7, #5
 1038 0028 1B78     		ldrb	r3, [r3]
 1039 002a 002B     		cmp	r3, #0
 1040 002c 01D1     		bne	.L44
 562:../Generated_Code/I2C2.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 1041              		.loc 1 562 0
 1042 002e 8123     		mov	r3, #129
 1043 0030 AAE0     		b	.L43
 1044              	.L44:
 563:../Generated_Code/I2C2.c ****   }
 564:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is the general call flag set (SelectSl
 1045              		.loc 1 564 0
 1046 0032 7B69     		ldr	r3, [r7, #20]
 1047 0034 1B78     		ldrb	r3, [r3]
 1048 0036 1A1C     		mov	r2, r3
 1049 0038 0823     		mov	r3, #8
 1050 003a 1340     		and	r3, r2
 1051 003c 01D0     		beq	.L45
 565:../Generated_Code/I2C2.c ****     return ERR_NOTAVAIL;               /* It is not possible to receive data - Call SelectSlaveDevi
 1052              		.loc 1 565 0
 1053 003e 0923     		mov	r3, #9
 1054 0040 A2E0     		b	.L43
 1055              	.L45:
 566:../Generated_Code/I2C2.c ****   }
 567:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 1056              		.loc 1 567 0
 1057 0042 7B69     		ldr	r3, [r7, #20]
 1058 0044 5B78     		ldrb	r3, [r3, #1]
 1059 0046 012B     		cmp	r3, #1
 1060 0048 12D1     		bne	.L46
 568:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1061              		.loc 1 568 0
 1062 004a 514B     		ldr	r3, .L56
 1063 004c DB78     		ldrb	r3, [r3, #3]
 1064 004e DBB2     		uxtb	r3, r3
 1065 0050 1A1C     		mov	r2, r3
 1066 0052 2023     		mov	r3, #32
 1067 0054 1340     		and	r3, r2
 1068 0056 09D1     		bne	.L47
 569:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1069              		.loc 1 569 0
 1070 0058 7B69     		ldr	r3, [r7, #20]
 1071 005a 1B78     		ldrb	r3, [r3]
 1072 005c 1A1C     		mov	r2, r3
 1073 005e 0123     		mov	r3, #1
 1074 0060 1340     		and	r3, r2
 568:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1075              		.loc 1 568 0
 1076 0062 03D1     		bne	.L47
 570:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1077              		.loc 1 570 0
 1078 0064 7B69     		ldr	r3, [r7, #20]
 1079 0066 DB88     		ldrh	r3, [r3, #6]
 569:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1080              		.loc 1 569 0
 1081 0068 002B     		cmp	r3, #0
 1082 006a 0DD0     		beq	.L48
 1083              	.L47:
 571:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 1084              		.loc 1 571 0
 1085 006c 0823     		mov	r3, #8
 1086 006e 8BE0     		b	.L43
 1087              	.L46:
 572:../Generated_Code/I2C2.c ****     }
 573:../Generated_Code/I2C2.c ****   } else {
 574:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1088              		.loc 1 574 0
 1089 0070 7B69     		ldr	r3, [r7, #20]
 1090 0072 1B78     		ldrb	r3, [r3]
 1091 0074 1A1C     		mov	r2, r3
 1092 0076 0123     		mov	r3, #1
 1093 0078 1340     		and	r3, r2
 1094 007a 03D1     		bne	.L49
 575:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1095              		.loc 1 575 0
 1096 007c 7B69     		ldr	r3, [r7, #20]
 1097 007e DB88     		ldrh	r3, [r3, #6]
 574:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1098              		.loc 1 574 0
 1099 0080 002B     		cmp	r3, #0
 1100 0082 01D0     		beq	.L48
 1101              	.L49:
 576:../Generated_Code/I2C2.c ****       return ERR_BUSY;               /* If yes then error */
 1102              		.loc 1 576 0
 1103 0084 0823     		mov	r3, #8
 1104 0086 7FE0     		b	.L43
 1105              	.L48:
 1106              	.LBB3:
 577:../Generated_Code/I2C2.c ****     }
 578:../Generated_Code/I2C2.c ****   }
 579:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 580:../Generated_Code/I2C2.c ****   EnterCritical();
 1107              		.loc 1 580 0
 1108 0088 3B1C     		mov	r3, r7
 1109 008a 1333     		add	r3, r3, #19
 1110              	@ 580 "../Generated_Code/I2C2.c" 1
 1111 008c EFF31080 		MRS R0, PRIMASK
 1112 0090 72B6     		CPSID i
 1113 0092 1870     		STRB R0, [r3]
 1114              	@ 0 "" 2
 1115              		.code	16
 1116 0094 3F4B     		ldr	r3, .L56+4
 1117 0096 1B78     		ldrb	r3, [r3]
 1118 0098 DBB2     		uxtb	r3, r3
 1119 009a 0133     		add	r3, r3, #1
 1120 009c DBB2     		uxtb	r3, r3
 1121 009e 3D4A     		ldr	r2, .L56+4
 1122 00a0 191C     		add	r1, r3, #0
 1123 00a2 1170     		strb	r1, [r2]
 1124 00a4 012B     		cmp	r3, #1
 1125 00a6 04D1     		bne	.L50
 1126              		.loc 1 580 0 is_stmt 0
 1127 00a8 3B1C     		mov	r3, r7
 1128 00aa 1333     		add	r3, r3, #19
 1129 00ac 1A78     		ldrb	r2, [r3]
 1130 00ae 3A4B     		ldr	r3, .L56+8
 1131 00b0 1A70     		strb	r2, [r3]
 1132              	.L50:
 1133              	.LBE3:
 581:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 1134              		.loc 1 581 0 is_stmt 1
 1135 00b2 7B69     		ldr	r3, [r7, #20]
 1136 00b4 1B78     		ldrb	r3, [r3]
 1137 00b6 0122     		mov	r2, #1
 1138 00b8 1343     		orr	r3, r2
 1139 00ba DAB2     		uxtb	r2, r3
 1140 00bc 7B69     		ldr	r3, [r7, #20]
 1141 00be 1A70     		strb	r2, [r3]
 582:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 1142              		.loc 1 582 0
 1143 00c0 7B69     		ldr	r3, [r7, #20]
 1144 00c2 BA68     		ldr	r2, [r7, #8]
 1145 00c4 9A60     		str	r2, [r3, #8]
 583:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 1146              		.loc 1 583 0
 1147 00c6 7B69     		ldr	r3, [r7, #20]
 1148 00c8 BA1D     		add	r2, r7, #6
 1149 00ca 1288     		ldrh	r2, [r2]
 1150 00cc DA80     		strh	r2, [r3, #6]
 584:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 1151              		.loc 1 584 0
 1152 00ce 7B69     		ldr	r3, [r7, #20]
 1153 00d0 7A1D     		add	r2, r7, #5
 1154 00d2 1278     		ldrb	r2, [r2]
 1155 00d4 5A70     		strb	r2, [r3, #1]
 585:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 1156              		.loc 1 585 0
 1157 00d6 2E4B     		ldr	r3, .L56
 1158 00d8 2D4A     		ldr	r2, .L56
 1159 00da 9278     		ldrb	r2, [r2, #2]
 1160 00dc D2B2     		uxtb	r2, r2
 1161 00de D2B2     		uxtb	r2, r2
 1162 00e0 1021     		mov	r1, #16
 1163 00e2 0A43     		orr	r2, r1
 1164 00e4 D2B2     		uxtb	r2, r2
 1165 00e6 D2B2     		uxtb	r2, r2
 1166 00e8 9A70     		strb	r2, [r3, #2]
 586:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 1167              		.loc 1 586 0
 1168 00ea 294B     		ldr	r3, .L56
 1169 00ec 9B78     		ldrb	r3, [r3, #2]
 1170 00ee DBB2     		uxtb	r3, r3
 1171 00f0 1A1C     		mov	r2, r3
 1172 00f2 2023     		mov	r3, #32
 1173 00f4 1340     		and	r3, r2
 1174 00f6 08D0     		beq	.L51
 587:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 1175              		.loc 1 587 0
 1176 00f8 254B     		ldr	r3, .L56
 1177 00fa 254A     		ldr	r2, .L56
 1178 00fc 9278     		ldrb	r2, [r2, #2]
 1179 00fe D2B2     		uxtb	r2, r2
 1180 0100 0421     		mov	r1, #4
 1181 0102 0A43     		orr	r2, r1
 1182 0104 D2B2     		uxtb	r2, r2
 1183 0106 9A70     		strb	r2, [r3, #2]
 1184 0108 09E0     		b	.L52
 1185              	.L51:
 588:../Generated_Code/I2C2.c ****   } else {
 589:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 1186              		.loc 1 589 0
 1187 010a 214B     		ldr	r3, .L56
 1188 010c 204A     		ldr	r2, .L56
 1189 010e 9278     		ldrb	r2, [r2, #2]
 1190 0110 D2B2     		uxtb	r2, r2
 1191 0112 D2B2     		uxtb	r2, r2
 1192 0114 2021     		mov	r1, #32
 1193 0116 0A43     		orr	r2, r1
 1194 0118 D2B2     		uxtb	r2, r2
 1195 011a D2B2     		uxtb	r2, r2
 1196 011c 9A70     		strb	r2, [r3, #2]
 1197              	.L52:
 590:../Generated_Code/I2C2.c ****   }
 591:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 1198              		.loc 1 591 0
 1199 011e 7B69     		ldr	r3, [r7, #20]
 1200 0120 1B78     		ldrb	r3, [r3]
 1201 0122 1A1C     		mov	r2, r3
 1202 0124 2023     		mov	r3, #32
 1203 0126 1340     		and	r3, r2
 1204 0128 0ED0     		beq	.L53
 592:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE|REP_ADDR_COMPLETE); /* Only one byte of address will b
 1205              		.loc 1 592 0
 1206 012a 7B69     		ldr	r3, [r7, #20]
 1207 012c 1B78     		ldrb	r3, [r3]
 1208 012e 0622     		mov	r2, #6
 1209 0130 1343     		orr	r3, r2
 1210 0132 DAB2     		uxtb	r2, r3
 1211 0134 7B69     		ldr	r3, [r7, #20]
 1212 0136 1A70     		strb	r2, [r3]
 593:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddr | 0x01U)); /* Send slave
 1213              		.loc 1 593 0
 1214 0138 154B     		ldr	r3, .L56
 1215 013a 7A69     		ldr	r2, [r7, #20]
 1216 013c 1279     		ldrb	r2, [r2, #4]
 1217 013e 0121     		mov	r1, #1
 1218 0140 0A43     		orr	r2, r1
 1219 0142 D2B2     		uxtb	r2, r2
 1220 0144 1A71     		strb	r2, [r3, #4]
 1221 0146 10E0     		b	.L54
 1222              	.L53:
 594:../Generated_Code/I2C2.c ****   } else {
 595:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 1223              		.loc 1 595 0
 1224 0148 7B69     		ldr	r3, [r7, #20]
 1225 014a 1B78     		ldrb	r3, [r3]
 1226 014c 1A1C     		mov	r2, r3
 1227 014e 1023     		mov	r3, #16
 1228 0150 1340     		and	r3, r2
 1229 0152 0AD0     		beq	.L54
 596:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 1230              		.loc 1 596 0
 1231 0154 7B69     		ldr	r3, [r7, #20]
 1232 0156 1B78     		ldrb	r3, [r3]
 1233 0158 0622     		mov	r2, #6
 1234 015a 9343     		bic	r3, r2
 1235 015c DAB2     		uxtb	r2, r3
 1236 015e 7B69     		ldr	r3, [r7, #20]
 1237 0160 1A70     		strb	r2, [r3]
 597:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 1238              		.loc 1 597 0
 1239 0162 0B4B     		ldr	r3, .L56
 1240 0164 7A69     		ldr	r2, [r7, #20]
 1241 0166 5279     		ldrb	r2, [r2, #5]
 1242 0168 1A71     		strb	r2, [r3, #4]
 1243              	.L54:
 598:../Generated_Code/I2C2.c ****     }
 599:../Generated_Code/I2C2.c ****   }
 600:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 601:../Generated_Code/I2C2.c ****   ExitCritical();
 1244              		.loc 1 601 0
 1245 016a 0A4B     		ldr	r3, .L56+4
 1246 016c 1B78     		ldrb	r3, [r3]
 1247 016e DBB2     		uxtb	r3, r3
 1248 0170 013B     		sub	r3, r3, #1
 1249 0172 DBB2     		uxtb	r3, r3
 1250 0174 074A     		ldr	r2, .L56+4
 1251 0176 191C     		add	r1, r3, #0
 1252 0178 1170     		strb	r1, [r2]
 1253 017a 002B     		cmp	r3, #0
 1254 017c 03D1     		bne	.L55
 1255              		.loc 1 601 0 is_stmt 0
 1256 017e 064B     		ldr	r3, .L56+8
 1257              	@ 601 "../Generated_Code/I2C2.c" 1
 1258 0180 1878     		ldrb r0, [r3]
 1259 0182 80F31088 		msr PRIMASK,r0;
 1260              		
 1261              	@ 0 "" 2
 1262              		.code	16
 1263              	.L55:
 602:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1264              		.loc 1 602 0 is_stmt 1
 1265 0186 0023     		mov	r3, #0
 1266              	.L43:
 603:../Generated_Code/I2C2.c **** }
 1267              		.loc 1 603 0
 1268 0188 181C     		mov	r0, r3
 1269 018a BD46     		mov	sp, r7
 1270 018c 06B0     		add	sp, sp, #24
 1271              		@ sp needed for prologue
 1272 018e 80BD     		pop	{r7, pc}
 1273              	.L57:
 1274              		.align	2
 1275              	.L56:
 1276 0190 00600640 		.word	1074159616
 1277 0194 00000000 		.word	SR_lock
 1278 0198 00000000 		.word	SR_reg
 1279              		.cfi_endproc
 1280              	.LFE4:
 1282              		.section	.text.I2C2_SelectSlaveDevice,"ax",%progbits
 1283              		.align	2
 1284              		.global	I2C2_SelectSlaveDevice
 1285              		.code	16
 1286              		.thumb_func
 1288              	I2C2_SelectSlaveDevice:
 1289              	.LFB5:
 604:../Generated_Code/I2C2.c **** 
 605:../Generated_Code/I2C2.c **** /*
 606:../Generated_Code/I2C2.c **** ** ===================================================================
 607:../Generated_Code/I2C2.c **** **     Method      :  I2C2_SelectSlaveDevice (component I2C_LDD)
 608:../Generated_Code/I2C2.c **** */
 609:../Generated_Code/I2C2.c **** /*!
 610:../Generated_Code/I2C2.c **** **     @brief
 611:../Generated_Code/I2C2.c **** **         This method selects a new slave for communication by its
 612:../Generated_Code/I2C2.c **** **         7-bit slave, 10-bit address or general call value. Any send
 613:../Generated_Code/I2C2.c **** **         or receive method directs to or from selected device, until
 614:../Generated_Code/I2C2.c **** **         a new slave device is selected by this method. This method
 615:../Generated_Code/I2C2.c **** **         is available for the MASTER mode.
 616:../Generated_Code/I2C2.c **** **     @param
 617:../Generated_Code/I2C2.c **** **         DeviceDataPtr   - Device data structure
 618:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 619:../Generated_Code/I2C2.c **** **     @param
 620:../Generated_Code/I2C2.c **** **         AddrType        - Specify type of slave address
 621:../Generated_Code/I2C2.c **** **                           (7bit, 10bit or general call address), e.g.
 622:../Generated_Code/I2C2.c **** **                           LDD_I2C_ADDRTYPE_7BITS.
 623:../Generated_Code/I2C2.c **** **     @param
 624:../Generated_Code/I2C2.c **** **         Addr            - 7bit or 10bit slave address value.
 625:../Generated_Code/I2C2.c **** **     @return
 626:../Generated_Code/I2C2.c **** **                         - Error code, possible codes:
 627:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 628:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The device is busy, wait until
 629:../Generated_Code/I2C2.c **** **                           the current operation is finished.
 630:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  The device is disabled.
 631:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 632:../Generated_Code/I2C2.c **** **                           the active clock configuration
 633:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS_TYPE -  Invalid address
 634:../Generated_Code/I2C2.c **** **                           type.
 635:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS -  Invalid address value.
 636:../Generated_Code/I2C2.c **** */
 637:../Generated_Code/I2C2.c **** /* ===================================================================*/
 638:../Generated_Code/I2C2.c **** LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TAddrType AddrType, LDD_I
 639:../Generated_Code/I2C2.c **** {
 1290              		.loc 1 639 0
 1291              		.cfi_startproc
 1292 0000 80B5     		push	{r7, lr}
 1293              	.LCFI15:
 1294              		.cfi_def_cfa_offset 8
 1295              		.cfi_offset 7, -8
 1296              		.cfi_offset 14, -4
 1297 0002 84B0     		sub	sp, sp, #16
 1298              	.LCFI16:
 1299              		.cfi_def_cfa_offset 24
 1300 0004 00AF     		add	r7, sp, #0
 1301              	.LCFI17:
 1302              		.cfi_def_cfa_register 7
 1303 0006 7860     		str	r0, [r7, #4]
 1304 0008 FB1C     		add	r3, r7, #3
 1305 000a 1970     		strb	r1, [r3]
 1306 000c 3B1C     		mov	r3, r7
 1307 000e 1A80     		strh	r2, [r3]
 640:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1308              		.loc 1 640 0
 1309 0010 7B68     		ldr	r3, [r7, #4]
 1310 0012 FB60     		str	r3, [r7, #12]
 641:../Generated_Code/I2C2.c **** 
 642:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) { /* Is the device in the active state
 1311              		.loc 1 642 0
 1312 0014 FB68     		ldr	r3, [r7, #12]
 1313 0016 1B78     		ldrb	r3, [r3]
 1314 0018 1A1C     		mov	r2, r3
 1315 001a 0123     		mov	r3, #1
 1316 001c 1340     		and	r3, r2
 1317 001e 01D0     		beq	.L59
 643:../Generated_Code/I2C2.c ****     return ERR_BUSY;                   /* If yes then error */
 1318              		.loc 1 643 0
 1319 0020 0823     		mov	r3, #8
 1320 0022 66E0     		b	.L60
 1321              	.L59:
 644:../Generated_Code/I2C2.c ****   }
 645:../Generated_Code/I2C2.c ****   switch (AddrType) {
 1322              		.loc 1 645 0
 1323 0024 FB1C     		add	r3, r7, #3
 1324 0026 1B78     		ldrb	r3, [r3]
 1325 0028 012B     		cmp	r3, #1
 1326 002a 1FD0     		beq	.L63
 1327 002c 022B     		cmp	r3, #2
 1328 002e 4ED0     		beq	.L64
 1329 0030 002B     		cmp	r3, #0
 1330 0032 5BD1     		bne	.L68
 1331              	.L62:
 646:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_7BITS:
 647:../Generated_Code/I2C2.c ****       if (Addr > 0x7FU) {              /* Test address value */
 1332              		.loc 1 647 0
 1333 0034 3B1C     		mov	r3, r7
 1334 0036 1B88     		ldrh	r3, [r3]
 1335 0038 7F2B     		cmp	r3, #127
 1336 003a 01D9     		bls	.L65
 648:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1337              		.loc 1 648 0
 1338 003c 8923     		mov	r3, #137
 1339 003e 58E0     		b	.L60
 1340              	.L65:
 649:../Generated_Code/I2C2.c ****       }
 650:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)((uint8_t)Addr << 0x01U); /* Set slave address */
 1341              		.loc 1 650 0
 1342 0040 3B1C     		mov	r3, r7
 1343 0042 1B88     		ldrh	r3, [r3]
 1344 0044 DBB2     		uxtb	r3, r3
 1345 0046 5B00     		lsl	r3, r3, #1
 1346 0048 DAB2     		uxtb	r2, r3
 1347 004a FB68     		ldr	r3, [r7, #12]
 1348 004c 1A71     		strb	r2, [r3, #4]
 651:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_10); /* Clear the general call flag 
 1349              		.loc 1 651 0
 1350 004e FB68     		ldr	r3, [r7, #12]
 1351 0050 1B78     		ldrb	r3, [r3]
 1352 0052 1822     		mov	r2, #24
 1353 0054 9343     		bic	r3, r2
 1354 0056 DAB2     		uxtb	r2, r3
 1355 0058 FB68     		ldr	r3, [r7, #12]
 1356 005a 1A70     		strb	r2, [r3]
 652:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_7; /* Set 7-bit address mode flag */
 1357              		.loc 1 652 0
 1358 005c FB68     		ldr	r3, [r7, #12]
 1359 005e 1B78     		ldrb	r3, [r3]
 1360 0060 2022     		mov	r2, #32
 1361 0062 1343     		orr	r3, r2
 1362 0064 DAB2     		uxtb	r2, r3
 1363 0066 FB68     		ldr	r3, [r7, #12]
 1364 0068 1A70     		strb	r2, [r3]
 653:../Generated_Code/I2C2.c ****     break;
 1365              		.loc 1 653 0
 1366 006a 41E0     		b	.L66
 1367              	.L63:
 654:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_10BITS:
 655:../Generated_Code/I2C2.c ****       if (Addr > 0x03FFU) {            /* Test address value */
 1368              		.loc 1 655 0
 1369 006c 3B1C     		mov	r3, r7
 1370 006e 1A88     		ldrh	r2, [r3]
 1371 0070 224B     		ldr	r3, .L69
 1372 0072 9A42     		cmp	r2, r3
 1373 0074 01D9     		bls	.L67
 656:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1374              		.loc 1 656 0
 1375 0076 8923     		mov	r3, #137
 1376 0078 3BE0     		b	.L60
 1377              	.L67:
 657:../Generated_Code/I2C2.c ****       }
 658:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)Addr; /* Set slave address - low byte */
 1378              		.loc 1 658 0
 1379 007a 3B1C     		mov	r3, r7
 1380 007c 1B88     		ldrh	r3, [r3]
 1381 007e DAB2     		uxtb	r2, r3
 1382 0080 FB68     		ldr	r3, [r7, #12]
 1383 0082 1A71     		strb	r2, [r3, #4]
 659:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh = (uint8_t)((uint16_t)Addr >> 0x07U); /* Set slave address - hig
 1384              		.loc 1 659 0
 1385 0084 3B1C     		mov	r3, r7
 1386 0086 1B88     		ldrh	r3, [r3]
 1387 0088 DB09     		lsr	r3, r3, #7
 1388 008a 9BB2     		uxth	r3, r3
 1389 008c DAB2     		uxtb	r2, r3
 1390 008e FB68     		ldr	r3, [r7, #12]
 1391 0090 5A71     		strb	r2, [r3, #5]
 660:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh &= 0x06U; /* Format address to 11110xx0 */
 1392              		.loc 1 660 0
 1393 0092 FB68     		ldr	r3, [r7, #12]
 1394 0094 5A79     		ldrb	r2, [r3, #5]
 1395 0096 0623     		mov	r3, #6
 1396 0098 1340     		and	r3, r2
 1397 009a DAB2     		uxtb	r2, r3
 1398 009c FB68     		ldr	r3, [r7, #12]
 1399 009e 5A71     		strb	r2, [r3, #5]
 661:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh |= 0xF0U;
 1400              		.loc 1 661 0
 1401 00a0 FB68     		ldr	r3, [r7, #12]
 1402 00a2 5B79     		ldrb	r3, [r3, #5]
 1403 00a4 1022     		mov	r2, #16
 1404 00a6 5242     		neg	r2, r2
 1405 00a8 1343     		orr	r3, r2
 1406 00aa DAB2     		uxtb	r2, r3
 1407 00ac FB68     		ldr	r3, [r7, #12]
 1408 00ae 5A71     		strb	r2, [r3, #5]
 662:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_7); /* Clear the general call flag a
 1409              		.loc 1 662 0
 1410 00b0 FB68     		ldr	r3, [r7, #12]
 1411 00b2 1B78     		ldrb	r3, [r3]
 1412 00b4 2822     		mov	r2, #40
 1413 00b6 9343     		bic	r3, r2
 1414 00b8 DAB2     		uxtb	r2, r3
 1415 00ba FB68     		ldr	r3, [r7, #12]
 1416 00bc 1A70     		strb	r2, [r3]
 663:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_10; /* Set 10-bit address mode flag */
 1417              		.loc 1 663 0
 1418 00be FB68     		ldr	r3, [r7, #12]
 1419 00c0 1B78     		ldrb	r3, [r3]
 1420 00c2 1022     		mov	r2, #16
 1421 00c4 1343     		orr	r3, r2
 1422 00c6 DAB2     		uxtb	r2, r3
 1423 00c8 FB68     		ldr	r3, [r7, #12]
 1424 00ca 1A70     		strb	r2, [r3]
 664:../Generated_Code/I2C2.c ****     break;
 1425              		.loc 1 664 0
 1426 00cc 10E0     		b	.L66
 1427              	.L64:
 665:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_GENERAL_CALL:
 666:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_7 | ADDR_10); /* Clear the 7-bit address flag and 1
 1428              		.loc 1 666 0
 1429 00ce FB68     		ldr	r3, [r7, #12]
 1430 00d0 1B78     		ldrb	r3, [r3]
 1431 00d2 3022     		mov	r2, #48
 1432 00d4 9343     		bic	r3, r2
 1433 00d6 DAB2     		uxtb	r2, r3
 1434 00d8 FB68     		ldr	r3, [r7, #12]
 1435 00da 1A70     		strb	r2, [r3]
 667:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= GENERAL_CALL; /* Set general call mode flag */
 1436              		.loc 1 667 0
 1437 00dc FB68     		ldr	r3, [r7, #12]
 1438 00de 1B78     		ldrb	r3, [r3]
 1439 00e0 0822     		mov	r2, #8
 1440 00e2 1343     		orr	r3, r2
 1441 00e4 DAB2     		uxtb	r2, r3
 1442 00e6 FB68     		ldr	r3, [r7, #12]
 1443 00e8 1A70     		strb	r2, [r3]
 668:../Generated_Code/I2C2.c ****     break;
 1444              		.loc 1 668 0
 1445 00ea 01E0     		b	.L66
 1446              	.L68:
 669:../Generated_Code/I2C2.c ****     default:
 670:../Generated_Code/I2C2.c ****       return ERR_PARAM_ADDRESS_TYPE;   /* If value of address type is invalid, return error */
 1447              		.loc 1 670 0
 1448 00ec 8D23     		mov	r3, #141
 1449 00ee 00E0     		b	.L60
 1450              	.L66:
 671:../Generated_Code/I2C2.c ****   }
 672:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1451              		.loc 1 672 0
 1452 00f0 0023     		mov	r3, #0
 1453              	.L60:
 673:../Generated_Code/I2C2.c **** }
 1454              		.loc 1 673 0
 1455 00f2 181C     		mov	r0, r3
 1456 00f4 BD46     		mov	sp, r7
 1457 00f6 04B0     		add	sp, sp, #16
 1458              		@ sp needed for prologue
 1459 00f8 80BD     		pop	{r7, pc}
 1460              	.L70:
 1461 00fa C046     		.align	2
 1462              	.L69:
 1463 00fc FF030000 		.word	1023
 1464              		.cfi_endproc
 1465              	.LFE5:
 1467              		.section	.text.I2C2_GetError,"ax",%progbits
 1468              		.align	2
 1469              		.global	I2C2_GetError
 1470              		.code	16
 1471              		.thumb_func
 1473              	I2C2_GetError:
 1474              	.LFB6:
 674:../Generated_Code/I2C2.c **** 
 675:../Generated_Code/I2C2.c **** /*
 676:../Generated_Code/I2C2.c **** ** ===================================================================
 677:../Generated_Code/I2C2.c **** **     Method      :  I2C2_GetError (component I2C_LDD)
 678:../Generated_Code/I2C2.c **** */
 679:../Generated_Code/I2C2.c **** /*!
 680:../Generated_Code/I2C2.c **** **     @brief
 681:../Generated_Code/I2C2.c **** **         Returns value of error mask, e.g. LDD_I2C_ARBIT_LOST.
 682:../Generated_Code/I2C2.c **** **     @param
 683:../Generated_Code/I2C2.c **** **         DeviceDataPtr   - Device data structure
 684:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 685:../Generated_Code/I2C2.c **** **     @param
 686:../Generated_Code/I2C2.c **** **         ErrorMaskPtr    - Pointer to a variable
 687:../Generated_Code/I2C2.c **** **                           where errors value mask will be stored.
 688:../Generated_Code/I2C2.c **** **     @return
 689:../Generated_Code/I2C2.c **** **                         - Error code, possible codes:
 690:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 691:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 692:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 693:../Generated_Code/I2C2.c **** **                           the active clock configuration
 694:../Generated_Code/I2C2.c **** */
 695:../Generated_Code/I2C2.c **** /* ===================================================================*/
 696:../Generated_Code/I2C2.c **** LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TErrorMask *ErrorMaskPtr)
 697:../Generated_Code/I2C2.c **** {
 1475              		.loc 1 697 0
 1476              		.cfi_startproc
 1477 0000 80B5     		push	{r7, lr}
 1478              	.LCFI18:
 1479              		.cfi_def_cfa_offset 8
 1480              		.cfi_offset 7, -8
 1481              		.cfi_offset 14, -4
 1482 0002 84B0     		sub	sp, sp, #16
 1483              	.LCFI19:
 1484              		.cfi_def_cfa_offset 24
 1485 0004 00AF     		add	r7, sp, #0
 1486              	.LCFI20:
 1487              		.cfi_def_cfa_register 7
 1488 0006 7860     		str	r0, [r7, #4]
 1489 0008 3960     		str	r1, [r7]
 698:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1490              		.loc 1 698 0
 1491 000a 7B68     		ldr	r3, [r7, #4]
 1492 000c FB60     		str	r3, [r7, #12]
 1493              	.LBB4:
 699:../Generated_Code/I2C2.c **** 
 700:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 701:../Generated_Code/I2C2.c ****   EnterCritical();
 1494              		.loc 1 701 0
 1495 000e 3B1C     		mov	r3, r7
 1496 0010 0B33     		add	r3, r3, #11
 1497              	@ 701 "../Generated_Code/I2C2.c" 1
 1498 0012 EFF31080 		MRS R0, PRIMASK
 1499 0016 72B6     		CPSID i
 1500 0018 1870     		STRB R0, [r3]
 1501              	@ 0 "" 2
 1502              		.code	16
 1503 001a 144B     		ldr	r3, .L75
 1504 001c 1B78     		ldrb	r3, [r3]
 1505 001e DBB2     		uxtb	r3, r3
 1506 0020 0133     		add	r3, r3, #1
 1507 0022 DBB2     		uxtb	r3, r3
 1508 0024 114A     		ldr	r2, .L75
 1509 0026 191C     		add	r1, r3, #0
 1510 0028 1170     		strb	r1, [r2]
 1511 002a 012B     		cmp	r3, #1
 1512 002c 04D1     		bne	.L72
 1513              		.loc 1 701 0 is_stmt 0
 1514 002e 3B1C     		mov	r3, r7
 1515 0030 0B33     		add	r3, r3, #11
 1516 0032 1A78     		ldrb	r2, [r3]
 1517 0034 0E4B     		ldr	r3, .L75+4
 1518 0036 1A70     		strb	r2, [r3]
 1519              	.L72:
 1520              	.LBE4:
 702:../Generated_Code/I2C2.c ****   *ErrorMaskPtr = DeviceDataPrv->ErrorMask; /* Return last value of error mask */
 1521              		.loc 1 702 0 is_stmt 1
 1522 0038 FB68     		ldr	r3, [r7, #12]
 1523 003a 5A88     		ldrh	r2, [r3, #2]
 1524 003c 3B68     		ldr	r3, [r7]
 1525 003e 1A80     		strh	r2, [r3]
 703:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;
 1526              		.loc 1 703 0
 1527 0040 FB68     		ldr	r3, [r7, #12]
 1528 0042 0022     		mov	r2, #0
 1529 0044 5A80     		strh	r2, [r3, #2]
 704:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 705:../Generated_Code/I2C2.c ****   ExitCritical();
 1530              		.loc 1 705 0
 1531 0046 094B     		ldr	r3, .L75
 1532 0048 1B78     		ldrb	r3, [r3]
 1533 004a DBB2     		uxtb	r3, r3
 1534 004c 013B     		sub	r3, r3, #1
 1535 004e DBB2     		uxtb	r3, r3
 1536 0050 064A     		ldr	r2, .L75
 1537 0052 191C     		add	r1, r3, #0
 1538 0054 1170     		strb	r1, [r2]
 1539 0056 002B     		cmp	r3, #0
 1540 0058 03D1     		bne	.L73
 1541              		.loc 1 705 0 is_stmt 0
 1542 005a 054B     		ldr	r3, .L75+4
 1543              	@ 705 "../Generated_Code/I2C2.c" 1
 1544 005c 1878     		ldrb r0, [r3]
 1545 005e 80F31088 		msr PRIMASK,r0;
 1546              		
 1547              	@ 0 "" 2
 1548              		.code	16
 1549              	.L73:
 706:../Generated_Code/I2C2.c ****   return ERR_OK;
 1550              		.loc 1 706 0 is_stmt 1
 1551 0062 0023     		mov	r3, #0
 707:../Generated_Code/I2C2.c **** }
 1552              		.loc 1 707 0
 1553 0064 181C     		mov	r0, r3
 1554 0066 BD46     		mov	sp, r7
 1555 0068 04B0     		add	sp, sp, #16
 1556              		@ sp needed for prologue
 1557 006a 80BD     		pop	{r7, pc}
 1558              	.L76:
 1559              		.align	2
 1560              	.L75:
 1561 006c 00000000 		.word	SR_lock
 1562 0070 00000000 		.word	SR_reg
 1563              		.cfi_endproc
 1564              	.LFE6:
 1566              		.text
 1567              	.Letext0:
 1568              		.file 2 "C:/Freescale/CW MCU v10.7/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1569              		.file 3 "D:/15. MyFactory/PREN/Microcontroller/FRDM KL25Z/Freedom_Accel/Generated_Code/PE_Types.h"
 1570              		.file 4 "C:/Freescale/CW MCU v10.7/MCU/ProcessorExpert/lib/Kinetis/iofiles/MKL25Z4.h"
 1571              		.file 5 "D:/15. MyFactory/PREN/Microcontroller/FRDM KL25Z/Freedom_Accel/Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 I2C2.c
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:24     .bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:27     .bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM:00000000 INT_I2C0__DEFAULT_RTOS_ISRPARAM
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:30     .text.I2C2_Interrupt:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:35     .text.I2C2_Interrupt:00000000 I2C2_Interrupt
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:466    .text.I2C2_Interrupt:000002b0 $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:472    .text.I2C2_Init:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:477    .text.I2C2_Init:00000000 I2C2_Init
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:642    .text.I2C2_Init:000000f8 $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:655    .text.I2C2_Deinit:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:660    .text.I2C2_Deinit:00000000 I2C2_Deinit
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:703    .text.I2C2_Deinit:00000030 $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:711    .text.I2C2_MasterSendBlock:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:716    .text.I2C2_MasterSendBlock:00000000 I2C2_MasterSendBlock
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:989    .text.I2C2_MasterSendBlock:00000190 $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:996    .text.I2C2_MasterReceiveBlock:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1001   .text.I2C2_MasterReceiveBlock:00000000 I2C2_MasterReceiveBlock
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1276   .text.I2C2_MasterReceiveBlock:00000190 $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1283   .text.I2C2_SelectSlaveDevice:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1288   .text.I2C2_SelectSlaveDevice:00000000 I2C2_SelectSlaveDevice
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1463   .text.I2C2_SelectSlaveDevice:000000fc $d
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1468   .text.I2C2_GetError:00000000 $t
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1473   .text.I2C2_GetError:00000000 I2C2_GetError
C:\Users\burak\AppData\Local\Temp\ccWRJFzv.s:1561   .text.I2C2_GetError:0000006c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
I2C2_OnMasterBlockSent
I2C2_OnMasterBlockReceived
I2C2_OnError
PE_LDD_DeviceDataList
SR_lock
SR_reg
